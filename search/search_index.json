{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Motivation Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. Beneath this simplicity lies a complex and versatile framework. The equations governing projectile motion involve both linear and quadratic relationships, making them accessible yet deeply insightful. What makes this topic particularly compelling is the number of free parameters involved in these equations, such as initial velocity, gravitational acceleration, and launch height. These parameters give rise to a diverse set of solutions that can describe a wide array of real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket. Theoretical Foundation Theoretical Foundation: Derivation from Newton's Laws Newton's Second Law Newton's second law states: \\[ \\mathbf{F} = m \\mathbf{a} \\] For a projectile under gravity, the force acting on it is: \\[ \\mathbf{F} = -mg \\hat{j} \\] This results in the differential equations: \\[ m \\frac{d^2 x}{dt^2} = 0, \\quad m \\frac{d^2 y}{dt^2} = -mg \\] Solving for Motion Horizontal Motion \\[ \\frac{d^2 x}{dt^2} = 0 \\] Integrating twice: \\[ \\frac{dx}{dt} = v_0 \\cos\\theta \\] \\[ x(t) = v_0 \\cos\\theta \\cdot t \\] Vertical Motion \\[ \\frac{d^2 y}{dt^2} = -g \\] Integrating twice: \\[ \\frac{dy}{dt} = v_0 \\sin\\theta - g t \\] \\[ y(t) = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 \\] Time of Flight The projectile hits the ground when y = 0 : \\[ t = \\frac{2 v_0 \\sin\\theta}{g} \\] Range Equation \\[ R = \\frac{v_0^2 \\sin 2\\theta}{g} \\] This equation shows the dependence of range on angle and velocity. Analysis of the Range To analyze the range, we compute the horizontal displacement as a function of the launch angle. The range is maximized at an angle of 45 degrees, assuming a level launch and landing surface. We also investigate how variations in initial velocity and gravity affect the range. Practical Applications The principles of projectile motion apply to various real-world scenarios, such as: Sports Physics: Understanding ball trajectories in soccer, basketball, and golf. Engineering: Designing ballistic trajectories for missiles and projectiles. Space Exploration: Calculating launch angles for rockets and planetary landers. Implementation Implemented Python script to simulate projectile motion and visualize the relationship between range and launch angle. import numpy as np import matplotlib.pyplot as plt def projectile_range(theta, v0, g=9.81): \"\"\" Compute the range of a projectile given an initial velocity and launch angle. :param theta: Launch angle in degrees :param v0: Initial velocity (m/s) :param g: Gravitational acceleration (m/s^2), default is Earth's gravity :return: Range of the projectile (m) \"\"\" theta_rad = np.radians(theta) return (v0 ** 2 * np.sin(2 * theta_rad)) / g # Define parameters v0 = 20 # Initial velocity in m/s angles = np.linspace(0, 90, 100) # Angle from 0 to 90 degrees ranges = [projectile_range(theta, v0) for theta in angles] # Plot the results plt.figure(figsize=(10, 5)) plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.xlabel(\"Angle of Projection (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range as a Function of Launch Angle\") plt.legend() plt.grid() plt.show() Single Velocity Simulation import numpy as np import matplotlib.pyplot as plt def projectile_range(theta, v0, g=9.81): theta_rad = np.radians(theta) return (v0 ** 2 * np.sin(2 * theta_rad)) / g v0 = 20 # Initial velocity in m/s angles = np.linspace(0, 90, 100) ranges = [projectile_range(theta, v0) for theta in angles] plt.figure(figsize=(10, 5)) plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.xlabel(\"Angle of Projection (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range as a Function of Launch Angle\") plt.legend() plt.grid() plt.savefig(\"single_velocity_plot.png\") plt.show() Comparison of Different Velocities velocities = [10, 20, 30] plt.figure(figsize=(10, 5)) for v in velocities: ranges = [projectile_range(theta, v) for theta in angles] plt.plot(angles, ranges, label=f'v0 = {v} m/s') plt.xlabel(\"Angle of Projection (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range for Different Initial Velocities\") plt.legend() plt.grid() plt.savefig(\"velocity_comparison.png\") plt.show() Colab Same Conditions, Different Planets planets = {\"Earth\": 9.81, \"Moon\": 1.62, \"Mars\": 3.71} plt.figure(figsize=(10, 5)) for planet, g in planets.items(): ranges = [projectile_range(theta, v0, g) for theta in angles] plt.plot(angles, ranges, label=f'{planet}') plt.xlabel(\"Angle of Projection (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Motion on Different Planets\") plt.legend() plt.grid() plt.savefig(\"planet_comparison.png\") plt.show() Same Velocity, Different Angles angles_to_compare = [15, 30, 45, 60, 75] time = np.linspace(0, 4, num=500) g = 9.81 plt.figure(figsize=(10, 5)) for theta in angles_to_compare: theta_rad = np.radians(theta) x_vals = v0 * np.cos(theta_rad) * time y_vals = v0 * np.sin(theta_rad) * time - 0.5 * g * time ** 2 valid_indices = y_vals >= 0 # Only plot points where y is non-negative plt.plot(x_vals[valid_indices], y_vals[valid_indices], label=f'{theta}\u00b0') plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.title(\"Projectile Motion for Different Angles\") plt.legend() plt.grid() plt.savefig(\"angle_comparison.png\") plt.show() Results The simulation confirms that the maximum range occurs at a 45-degree angle. The graph clearly illustrates how the range varies with launch angle, demonstrating the theoretical prediction. The simulations confirm that the maximum range occurs at a 45-degree angle. The plots illustrate how different parameters affect the range: Higher velocities result in greater ranges. Lower gravity (e.g., on the Moon) increases the range, while higher gravity (e.g., on Jupiter) decreases it. Initial height variations shift the trajectory but do not affect the fundamental 45-degree maximum range rule. Different launch angles demonstrate the sinusoidal dependence of range on angle. Discussion and Future Work While this model provides a solid understanding of projectile motion, real-world conditions introduce additional complexities such as: Air resistance: Affects the range and trajectory. Uneven terrain: Impacts the landing position. Wind effects: Alters the motion path. Future work could incorporate these factors to create a more comprehensive simulation of projectile motion. Conclusion This analysis highlights the importance of launch angle in projectile motion. Through theoretical derivations, computational simulations, and graphical representations, we have demonstrated how different parameters influence the projectile's range. This study serves as a foundation for further investigations into more complex projectile dynamics. Source Colab","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. Beneath this simplicity lies a complex and versatile framework. The equations governing projectile motion involve both linear and quadratic relationships, making them accessible yet deeply insightful. What makes this topic particularly compelling is the number of free parameters involved in these equations, such as initial velocity, gravitational acceleration, and launch height. These parameters give rise to a diverse set of solutions that can describe a wide array of real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#theoretical-foundation","text":"","title":"Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#theoretical-foundation-derivation-from-newtons-laws","text":"","title":"Theoretical Foundation: Derivation from Newton's Laws"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#newtons-second-law","text":"Newton's second law states: \\[ \\mathbf{F} = m \\mathbf{a} \\] For a projectile under gravity, the force acting on it is: \\[ \\mathbf{F} = -mg \\hat{j} \\] This results in the differential equations: \\[ m \\frac{d^2 x}{dt^2} = 0, \\quad m \\frac{d^2 y}{dt^2} = -mg \\]","title":"Newton's Second Law"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#solving-for-motion","text":"","title":"Solving for Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion","text":"\\[ \\frac{d^2 x}{dt^2} = 0 \\] Integrating twice: \\[ \\frac{dx}{dt} = v_0 \\cos\\theta \\] \\[ x(t) = v_0 \\cos\\theta \\cdot t \\]","title":"Horizontal Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion","text":"\\[ \\frac{d^2 y}{dt^2} = -g \\] Integrating twice: \\[ \\frac{dy}{dt} = v_0 \\sin\\theta - g t \\] \\[ y(t) = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 \\]","title":"Vertical Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"The projectile hits the ground when y = 0 : \\[ t = \\frac{2 v_0 \\sin\\theta}{g} \\]","title":"Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-equation","text":"\\[ R = \\frac{v_0^2 \\sin 2\\theta}{g} \\] This equation shows the dependence of range on angle and velocity.","title":"Range Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#analysis-of-the-range","text":"To analyze the range, we compute the horizontal displacement as a function of the launch angle. The range is maximized at an angle of 45 degrees, assuming a level launch and landing surface. We also investigate how variations in initial velocity and gravity affect the range.","title":"Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#practical-applications","text":"The principles of projectile motion apply to various real-world scenarios, such as: Sports Physics: Understanding ball trajectories in soccer, basketball, and golf. Engineering: Designing ballistic trajectories for missiles and projectiles. Space Exploration: Calculating launch angles for rockets and planetary landers.","title":"Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#implementation","text":"Implemented Python script to simulate projectile motion and visualize the relationship between range and launch angle. import numpy as np import matplotlib.pyplot as plt def projectile_range(theta, v0, g=9.81): \"\"\" Compute the range of a projectile given an initial velocity and launch angle. :param theta: Launch angle in degrees :param v0: Initial velocity (m/s) :param g: Gravitational acceleration (m/s^2), default is Earth's gravity :return: Range of the projectile (m) \"\"\" theta_rad = np.radians(theta) return (v0 ** 2 * np.sin(2 * theta_rad)) / g # Define parameters v0 = 20 # Initial velocity in m/s angles = np.linspace(0, 90, 100) # Angle from 0 to 90 degrees ranges = [projectile_range(theta, v0) for theta in angles] # Plot the results plt.figure(figsize=(10, 5)) plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.xlabel(\"Angle of Projection (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range as a Function of Launch Angle\") plt.legend() plt.grid() plt.show()","title":"Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#single-velocity-simulation","text":"import numpy as np import matplotlib.pyplot as plt def projectile_range(theta, v0, g=9.81): theta_rad = np.radians(theta) return (v0 ** 2 * np.sin(2 * theta_rad)) / g v0 = 20 # Initial velocity in m/s angles = np.linspace(0, 90, 100) ranges = [projectile_range(theta, v0) for theta in angles] plt.figure(figsize=(10, 5)) plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.xlabel(\"Angle of Projection (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range as a Function of Launch Angle\") plt.legend() plt.grid() plt.savefig(\"single_velocity_plot.png\") plt.show()","title":"Single Velocity Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#comparison-of-different-velocities","text":"velocities = [10, 20, 30] plt.figure(figsize=(10, 5)) for v in velocities: ranges = [projectile_range(theta, v) for theta in angles] plt.plot(angles, ranges, label=f'v0 = {v} m/s') plt.xlabel(\"Angle of Projection (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range for Different Initial Velocities\") plt.legend() plt.grid() plt.savefig(\"velocity_comparison.png\") plt.show() Colab","title":"Comparison of Different Velocities"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#same-conditions-different-planets","text":"planets = {\"Earth\": 9.81, \"Moon\": 1.62, \"Mars\": 3.71} plt.figure(figsize=(10, 5)) for planet, g in planets.items(): ranges = [projectile_range(theta, v0, g) for theta in angles] plt.plot(angles, ranges, label=f'{planet}') plt.xlabel(\"Angle of Projection (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Motion on Different Planets\") plt.legend() plt.grid() plt.savefig(\"planet_comparison.png\") plt.show()","title":"Same Conditions, Different Planets"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#same-velocity-different-angles","text":"angles_to_compare = [15, 30, 45, 60, 75] time = np.linspace(0, 4, num=500) g = 9.81 plt.figure(figsize=(10, 5)) for theta in angles_to_compare: theta_rad = np.radians(theta) x_vals = v0 * np.cos(theta_rad) * time y_vals = v0 * np.sin(theta_rad) * time - 0.5 * g * time ** 2 valid_indices = y_vals >= 0 # Only plot points where y is non-negative plt.plot(x_vals[valid_indices], y_vals[valid_indices], label=f'{theta}\u00b0') plt.xlabel(\"Horizontal Distance (m)\") plt.ylabel(\"Vertical Distance (m)\") plt.title(\"Projectile Motion for Different Angles\") plt.legend() plt.grid() plt.savefig(\"angle_comparison.png\") plt.show()","title":"Same Velocity, Different Angles"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#results","text":"The simulation confirms that the maximum range occurs at a 45-degree angle. The graph clearly illustrates how the range varies with launch angle, demonstrating the theoretical prediction. The simulations confirm that the maximum range occurs at a 45-degree angle. The plots illustrate how different parameters affect the range: Higher velocities result in greater ranges. Lower gravity (e.g., on the Moon) increases the range, while higher gravity (e.g., on Jupiter) decreases it. Initial height variations shift the trajectory but do not affect the fundamental 45-degree maximum range rule. Different launch angles demonstrate the sinusoidal dependence of range on angle.","title":"Results"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#discussion-and-future-work","text":"While this model provides a solid understanding of projectile motion, real-world conditions introduce additional complexities such as: Air resistance: Affects the range and trajectory. Uneven terrain: Impacts the landing position. Wind effects: Alters the motion path. Future work could incorporate these factors to create a more comprehensive simulation of projectile motion.","title":"Discussion and Future Work"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"This analysis highlights the importance of launch angle in projectile motion. Through theoretical derivations, computational simulations, and graphical representations, we have demonstrated how different parameters influence the projectile's range. This study serves as a foundation for further investigations into more complex projectile dynamics.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#source","text":"Colab","title":"Source"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a fundamental example of nonlinear dynamics, demonstrating a rich spectrum of behaviors due to the interplay between damping, restoring forces, and external driving forces. Unlike a simple pendulum, which exhibits predictable periodic motion, the forced damped pendulum can display resonance, quasiperiodicity, and even chaotic motion depending on system parameters. Understanding these behaviors is crucial in applications ranging from mechanical resonance in engineering to the study of climate systems and electrical circuits. Theoretical Foundation Governing Equation The equation of motion for a forced damped pendulum is given by: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + c\\sin(\\theta) = A\\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(b\\) is the damping coefficient, - \\(c\\) is the restoring force parameter (related to gravity and the length of the pendulum), - \\(A\\) is the amplitude of the external forcing, - \\(\\omega\\) is the driving frequency. For small angles, where \\(\\theta \\approx \\sin\\theta\\) , this equation reduces to a linear form, leading to approximate solutions that describe simple harmonic motion. However, for larger angles, the nonlinearity introduces complex behaviors, including chaotic dynamics. Resonance and Stability When the driving frequency \\(\\omega\\) matches the natural frequency of the pendulum, resonance occurs, leading to large oscillations. Stability analysis reveals that certain parameter ranges lead to periodic, quasiperiodic, or chaotic behavior, depending on the damping and driving force. Analysis of Dynamics To explore the system\u2019s behavior, we analyze the influence of key parameters: Damping coefficient ( \\(b\\) ): High damping suppresses oscillations, while low damping allows sustained motion. Driving amplitude ( \\(A\\) ): Increasing the driving force can push the system into chaotic regimes. Driving frequency ( \\(\\omega\\) ): The frequency affects resonance conditions and synchronization. Practical Applications Colab The forced damped pendulum model is relevant to various real-world systems: - Energy harvesting devices: Exploiting resonance for efficient energy conversion. - Suspension bridges: Studying oscillatory behavior to prevent resonance-related structural failures. - Oscillating electrical circuits: Analogous to the dynamics of driven RLC circuits. Computational Implementation We implemented a numerical simulation using Python\u2019s solve_ivp function to integrate the differential equation. The simulation provides: - Time evolution plots of the pendulum\u2019s motion. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g, l, b, A, omega_d = 9.81, 1.0, 0.2, 1.2, 2.0 # Equation of motion def pendulum(t, y): theta, omega = y return [omega, -b * omega - (g / l) * np.sin(theta) + A * np.cos(omega_d * t)] # Solve ODE t_span, t_eval = (0, 50), np.linspace(0, 50, 1000) sol = solve_ivp(pendulum, t_span, [0.5, 0.0], t_eval=t_eval, method='RK45') # Plot plt.figure(figsize=(8, 5)) plt.plot(sol.t, sol.y[0], 'b', label=r'$\\theta(t)$') plt.xlabel('Time (s)') plt.ylabel('Angle \u03b8 (rad)') plt.title('Time Evolution of the Forced Damped Pendulum') plt.legend() plt.grid() plt.show() Phase portraits to visualize transitions to chaotic behavior. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g, l, b, A, omega_d = 9.81, 1.0, 0.2, 1.2, 2.0 # Equation of motion def pendulum(t, y): theta, omega = y return [omega, -b * omega - (g / l) * np.sin(theta) + A * np.cos(omega_d * t)] # Solve ODE t_span, t_eval = (0, 50), np.linspace(0, 50, 1000) sol = solve_ivp(pendulum, t_span, [0.5, 0.0], t_eval=t_eval, method='RK45') # Plot plt.figure(figsize=(8, 5)) plt.plot(sol.y[0], sol.y[1], 'r', label=r'$\\omega$ vs $\\theta$') plt.xlabel('Angle \u03b8 (rad)') plt.ylabel('Angular Velocity \u03c9 (rad/s)') plt.title('Phase Portrait of the Forced Damped Pendulum') plt.legend() plt.grid() plt.show() Poincar\u00e9 sections import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g, l, b, A, omega_d = 9.81, 1.0, 0.2, 1.2, 2.0 # Equation of motion def pendulum(t, y): theta, omega = y return [omega, -b * omega - (g / l) * np.sin(theta) + A * np.cos(omega_d * t)] # Solve ODE t_span, t_eval = (0, 200), np.linspace(0, 200, 10000) sol = solve_ivp(pendulum, t_span, [0.5, 0.0], t_eval=t_eval, method='RK45') # Extract points at multiples of the driving period T = 2 * np.pi / omega_d poincare_t = np.arange(0, 200, T) poincare_points = [] for t in poincare_t: idx = (np.abs(sol.t - t)).argmin() poincare_points.append(sol.y[:, idx]) poincare_points = np.array(poincare_points) # Plot plt.figure(figsize=(8, 5)) plt.scatter(poincare_points[:, 0] % (2 * np.pi), poincare_points[:, 1], s=5, color='g') plt.xlabel('Angle \u03b8 (mod 2\u03c0)') plt.ylabel('Angular Velocity \u03c9') plt.title(\"Poincar\u00e9 Section\") plt.grid() plt.show() bifurcation diagrams to explore the system\u2019s sensitivity to initial conditions. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g, l, b, omega_d = 9.81, 1.0, 0.2, 2.0 A_values = np.linspace(0.5, 1.5, 100) T = 2 * np.pi / omega_d theta_final = [] # Equation of motion def pendulum(t, y, A): theta, omega = y return [omega, -b * omega - (g / l) * np.sin(theta) + A * np.cos(omega_d * t)] for A in A_values: sol = solve_ivp(pendulum, (0, 300), [0.5, 0.0], args=(A,), t_eval=np.linspace(200, 300, 5000)) poincare_t = np.arange(200, 300, T) poincare_points = [sol.y[0, (np.abs(sol.t - t)).argmin()] for t in poincare_t] theta_final.append(poincare_points) # Flatten lists theta_final = np.array(theta_final) # Plot plt.figure(figsize=(8, 5)) for i, A in enumerate(A_values): plt.scatter([A] * len(theta_final[i]), theta_final[i] % (2 * np.pi), s=1, color='b') plt.xlabel('Driving Amplitude A') plt.ylabel('Angle \u03b8 (mod 2\u03c0)') plt.title(\"Bifurcation Diagram\") plt.grid() plt.show() Results and Discussion Graphical analysis highlights: - Regular oscillations for low forcing amplitudes. Forced, Damped Pendulum A forced, damped pendulum follows the equation: \\[ \\ddot{\\theta} + 2\\beta \\dot{\\theta} + \\omega_0^2 \\sin\\theta = F_0 \\cos(\\omega t) \\] where: \\(\\theta\\) is the angular displacement, \\(\\beta\\) is the damping coefficient, \\(\\omega_0\\) is the natural frequency, \\(F_0\\) is the forcing amplitude, \\(\\omega\\) is the driving frequency. Resonance Explanation Resonance occurs when the external driving frequency ( \\(\\omega\\) ) is close to the system\u2019s natural frequency ( \\(\\omega_0\\) ). The amplitude of oscillations grows significantly when damping is low: \\[ A \\approx \\frac{F_0}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + 4\\beta^2\\omega^2}} \\] For small damping ( \\(\\beta \\approx 0\\) ), at resonance ( \\(\\omega \\approx \\omega_0\\) ): \\[ A \\approx \\frac{F_0}{2\\beta \\omega_0} \\] which shows that smaller damping leads to a higher amplitude. Resonance behavior at specific driving frequencies. Scenario Analysis 1. No force, no damping The pendulum oscillates indefinitely with constant amplitude. This is because there is no external force to drive the system and no damping to dissipate energy. The motion follows simple harmonic oscillation. 2. No force, with damping The amplitude decays over time due to energy loss. Damping removes energy from the system, causing the oscillations to slow down and eventually stop. The motion follows an exponentially decaying sinusoidal pattern. 3. Large forcing The pendulum exhibits higher amplitude oscillations due to the external driving force. A strong external force overcomes damping effects and drives the system with larger oscillations. The response remains periodic but with greater amplitudes. 4. Resonance The oscillations grow significantly when the driving frequency matches the natural frequency. At resonance, the system absorbs energy efficiently, leading to large amplitudes. If damping is minimal, amplitudes can increase dramatically, potentially causing instability. Chaotic motion for certain parameter sets, demonstrated by non-repeating phase space trajectories. Limitations and Extensions The model assumes a simple sinusoidal driving force; more complex forcing functions can be explored. Nonlinear damping effects could provide further insights into real-world applications. Conclusion The forced damped pendulum serves as a compelling case study in nonlinear dynamics. By varying key parameters, we observe a transition from simple periodic motion to chaos, offering insights into both fundamental physics and engineering applications. Further computational studies can deepen our understanding of its complex behavior. Source Colab","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a fundamental example of nonlinear dynamics, demonstrating a rich spectrum of behaviors due to the interplay between damping, restoring forces, and external driving forces. Unlike a simple pendulum, which exhibits predictable periodic motion, the forced damped pendulum can display resonance, quasiperiodicity, and even chaotic motion depending on system parameters. Understanding these behaviors is crucial in applications ranging from mechanical resonance in engineering to the study of climate systems and electrical circuits.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#theoretical-foundation","text":"","title":"Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-equation","text":"The equation of motion for a forced damped pendulum is given by: \\[ \\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + c\\sin(\\theta) = A\\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(b\\) is the damping coefficient, - \\(c\\) is the restoring force parameter (related to gravity and the length of the pendulum), - \\(A\\) is the amplitude of the external forcing, - \\(\\omega\\) is the driving frequency. For small angles, where \\(\\theta \\approx \\sin\\theta\\) , this equation reduces to a linear form, leading to approximate solutions that describe simple harmonic motion. However, for larger angles, the nonlinearity introduces complex behaviors, including chaotic dynamics.","title":"Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-and-stability","text":"When the driving frequency \\(\\omega\\) matches the natural frequency of the pendulum, resonance occurs, leading to large oscillations. Stability analysis reveals that certain parameter ranges lead to periodic, quasiperiodic, or chaotic behavior, depending on the damping and driving force.","title":"Resonance and Stability"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#analysis-of-dynamics","text":"To explore the system\u2019s behavior, we analyze the influence of key parameters: Damping coefficient ( \\(b\\) ): High damping suppresses oscillations, while low damping allows sustained motion. Driving amplitude ( \\(A\\) ): Increasing the driving force can push the system into chaotic regimes. Driving frequency ( \\(\\omega\\) ): The frequency affects resonance conditions and synchronization.","title":"Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#practical-applications","text":"Colab The forced damped pendulum model is relevant to various real-world systems: - Energy harvesting devices: Exploiting resonance for efficient energy conversion. - Suspension bridges: Studying oscillatory behavior to prevent resonance-related structural failures. - Oscillating electrical circuits: Analogous to the dynamics of driven RLC circuits.","title":"Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#computational-implementation","text":"We implemented a numerical simulation using Python\u2019s solve_ivp function to integrate the differential equation. The simulation provides: - Time evolution plots of the pendulum\u2019s motion. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g, l, b, A, omega_d = 9.81, 1.0, 0.2, 1.2, 2.0 # Equation of motion def pendulum(t, y): theta, omega = y return [omega, -b * omega - (g / l) * np.sin(theta) + A * np.cos(omega_d * t)] # Solve ODE t_span, t_eval = (0, 50), np.linspace(0, 50, 1000) sol = solve_ivp(pendulum, t_span, [0.5, 0.0], t_eval=t_eval, method='RK45') # Plot plt.figure(figsize=(8, 5)) plt.plot(sol.t, sol.y[0], 'b', label=r'$\\theta(t)$') plt.xlabel('Time (s)') plt.ylabel('Angle \u03b8 (rad)') plt.title('Time Evolution of the Forced Damped Pendulum') plt.legend() plt.grid() plt.show() Phase portraits to visualize transitions to chaotic behavior. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g, l, b, A, omega_d = 9.81, 1.0, 0.2, 1.2, 2.0 # Equation of motion def pendulum(t, y): theta, omega = y return [omega, -b * omega - (g / l) * np.sin(theta) + A * np.cos(omega_d * t)] # Solve ODE t_span, t_eval = (0, 50), np.linspace(0, 50, 1000) sol = solve_ivp(pendulum, t_span, [0.5, 0.0], t_eval=t_eval, method='RK45') # Plot plt.figure(figsize=(8, 5)) plt.plot(sol.y[0], sol.y[1], 'r', label=r'$\\omega$ vs $\\theta$') plt.xlabel('Angle \u03b8 (rad)') plt.ylabel('Angular Velocity \u03c9 (rad/s)') plt.title('Phase Portrait of the Forced Damped Pendulum') plt.legend() plt.grid() plt.show() Poincar\u00e9 sections import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g, l, b, A, omega_d = 9.81, 1.0, 0.2, 1.2, 2.0 # Equation of motion def pendulum(t, y): theta, omega = y return [omega, -b * omega - (g / l) * np.sin(theta) + A * np.cos(omega_d * t)] # Solve ODE t_span, t_eval = (0, 200), np.linspace(0, 200, 10000) sol = solve_ivp(pendulum, t_span, [0.5, 0.0], t_eval=t_eval, method='RK45') # Extract points at multiples of the driving period T = 2 * np.pi / omega_d poincare_t = np.arange(0, 200, T) poincare_points = [] for t in poincare_t: idx = (np.abs(sol.t - t)).argmin() poincare_points.append(sol.y[:, idx]) poincare_points = np.array(poincare_points) # Plot plt.figure(figsize=(8, 5)) plt.scatter(poincare_points[:, 0] % (2 * np.pi), poincare_points[:, 1], s=5, color='g') plt.xlabel('Angle \u03b8 (mod 2\u03c0)') plt.ylabel('Angular Velocity \u03c9') plt.title(\"Poincar\u00e9 Section\") plt.grid() plt.show() bifurcation diagrams to explore the system\u2019s sensitivity to initial conditions. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Parameters g, l, b, omega_d = 9.81, 1.0, 0.2, 2.0 A_values = np.linspace(0.5, 1.5, 100) T = 2 * np.pi / omega_d theta_final = [] # Equation of motion def pendulum(t, y, A): theta, omega = y return [omega, -b * omega - (g / l) * np.sin(theta) + A * np.cos(omega_d * t)] for A in A_values: sol = solve_ivp(pendulum, (0, 300), [0.5, 0.0], args=(A,), t_eval=np.linspace(200, 300, 5000)) poincare_t = np.arange(200, 300, T) poincare_points = [sol.y[0, (np.abs(sol.t - t)).argmin()] for t in poincare_t] theta_final.append(poincare_points) # Flatten lists theta_final = np.array(theta_final) # Plot plt.figure(figsize=(8, 5)) for i, A in enumerate(A_values): plt.scatter([A] * len(theta_final[i]), theta_final[i] % (2 * np.pi), s=1, color='b') plt.xlabel('Driving Amplitude A') plt.ylabel('Angle \u03b8 (mod 2\u03c0)') plt.title(\"Bifurcation Diagram\") plt.grid() plt.show()","title":"Computational Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#results-and-discussion","text":"Graphical analysis highlights: - Regular oscillations for low forcing amplitudes.","title":"Results and Discussion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-damped-pendulum","text":"A forced, damped pendulum follows the equation: \\[ \\ddot{\\theta} + 2\\beta \\dot{\\theta} + \\omega_0^2 \\sin\\theta = F_0 \\cos(\\omega t) \\] where: \\(\\theta\\) is the angular displacement, \\(\\beta\\) is the damping coefficient, \\(\\omega_0\\) is the natural frequency, \\(F_0\\) is the forcing amplitude, \\(\\omega\\) is the driving frequency.","title":"Forced, Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-explanation","text":"Resonance occurs when the external driving frequency ( \\(\\omega\\) ) is close to the system\u2019s natural frequency ( \\(\\omega_0\\) ). The amplitude of oscillations grows significantly when damping is low: \\[ A \\approx \\frac{F_0}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + 4\\beta^2\\omega^2}} \\] For small damping ( \\(\\beta \\approx 0\\) ), at resonance ( \\(\\omega \\approx \\omega_0\\) ): \\[ A \\approx \\frac{F_0}{2\\beta \\omega_0} \\] which shows that smaller damping leads to a higher amplitude. Resonance behavior at specific driving frequencies.","title":"Resonance Explanation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#scenario-analysis","text":"","title":"Scenario Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-no-force-no-damping","text":"The pendulum oscillates indefinitely with constant amplitude. This is because there is no external force to drive the system and no damping to dissipate energy. The motion follows simple harmonic oscillation.","title":"1. No force, no damping"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-no-force-with-damping","text":"The amplitude decays over time due to energy loss. Damping removes energy from the system, causing the oscillations to slow down and eventually stop. The motion follows an exponentially decaying sinusoidal pattern.","title":"2. No force, with damping"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-large-forcing","text":"The pendulum exhibits higher amplitude oscillations due to the external driving force. A strong external force overcomes damping effects and drives the system with larger oscillations. The response remains periodic but with greater amplitudes.","title":"3. Large forcing"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-resonance","text":"The oscillations grow significantly when the driving frequency matches the natural frequency. At resonance, the system absorbs energy efficiently, leading to large amplitudes. If damping is minimal, amplitudes can increase dramatically, potentially causing instability. Chaotic motion for certain parameter sets, demonstrated by non-repeating phase space trajectories.","title":"4. Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#limitations-and-extensions","text":"The model assumes a simple sinusoidal driving force; more complex forcing functions can be explored. Nonlinear damping effects could provide further insights into real-world applications.","title":"Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#conclusion","text":"The forced damped pendulum serves as a compelling case study in nonlinear dynamics. By varying key parameters, we observe a transition from simple periodic motion to chaos, offering insights into both fundamental physics and engineering applications. Further computational studies can deepen our understanding of its complex behavior.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#source","text":"Colab","title":"Source"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Gravity: Orbital Period and Orbital Radius Motivation Kepler\u2019s Third Law states that the square of the orbital period ( \\(T^2\\) ) is proportional to the cube of the orbital radius ( \\(r^3\\) ). This fundamental relationship provides critical insights into celestial mechanics, governing planetary orbits, satellite motion, and gravitational interactions on both small and cosmic scales. Understanding this law allows astronomers to determine planetary masses, calculate distances in space, and analyze the stability of orbits. Derivation of Kepler's Third Law For a body in a circular orbit around a massive central body (e.g., a planet orbiting a star), the centripetal force required to maintain the orbit is provided by gravitational attraction: \\[ F_{\\text{gravity}} = F_{\\text{centripetal}} \\] \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Since the orbital velocity \\(v\\) is related to the period \\(T\\) by: \\[ v = \\frac{2\\pi r}{T} \\] Substituting this into the equation: \\[ \\frac{G M m}{r^2} = \\frac{m (2\\pi r)^2}{T^2 r} \\] Canceling \\(m\\) and simplifying: \\[ \\frac{G M}{r^2} = \\frac{4\\pi^2 r}{T^2} \\] Rearranging: \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] This confirms that \\(T^2 \\propto r^3\\) , meaning the square of the orbital period is proportional to the cube of the orbital radius. Implications in Astronomy Planetary Mass Calculation: Given the orbital period and radius of a planet's moon, one can estimate the planet\u2019s mass using Kepler\u2019s Law. Solar System Analysis: The law allows astronomers to determine distances between planets and their stars even without direct measurements. Satellite Orbits: Understanding this relationship helps in designing stable satellite trajectories for communication and observation. Exoplanet Detection: By measuring periodic changes in a star\u2019s brightness due to transiting planets, scientists can infer planetary orbits. Real-World Examples 1. The Moon\u2019s Orbit Around Earth The Moon orbits Earth at an average radius of \\(3.84 \\times 10^5\\) km with a period of 27.3 days. Using Kepler\u2019s Law, we can estimate Earth's mass and verify astronomical models. 2. The Solar System The orbits of planets around the Sun follow Kepler\u2019s Third Law, with larger orbits corresponding to longer periods. For example: Earth: \\(r = 1\\) AU, \\(T = 1\\) year Mars: \\(r \\approx 1.52\\) AU, \\(T \\approx 1.88\\) years Jupiter: \\(r \\approx 5.2\\) AU, \\(T \\approx 11.86\\) years Computational Simulation To visualize the orbital relationship, we employ Python simulations: Circular Orbit Simulation: Generates a circular path for an orbiting body. Marks the central mass. import matplotlib.pyplot as plt import numpy as np # Orbital period (T) in Earth years and average orbital radius (r) in AU for each planet # Data from NASA sources planets = { \"Mercury\": {\"T\": 0.240846, \"r\": 0.387}, \"Venus\": {\"T\": 0.615, \"r\": 0.723}, \"Earth\": {\"T\": 1.0, \"r\": 1.0}, \"Mars\": {\"T\": 1.881, \"r\": 1.524}, } # Calculate T^2 and r^3 for each planet T_squared = [data[\"T\"] ** 2 for data in planets.values()] r_cubed = [data[\"r\"] ** 3 for data in planets.values()] labels = list(planets.keys()) # Fit a linear regression line to the data (T^2 = k * r^3) coefficients = np.polyfit(r_cubed, T_squared, 1) k, b = coefficients # Generate line for the fit r_cubed_line = np.linspace(min(r_cubed), max(r_cubed), 100) T_squared_line = k * r_cubed_line + b # Plot the data points and the regression line plt.figure(figsize=(8, 6)) plt.scatter(r_cubed, T_squared, color='blue', label='Planets') # Add labels for each point for i, label in enumerate(labels): plt.text(r_cubed[i] + 0.005, T_squared[i], label, fontsize=9) # Plot the fitted line plt.plot(r_cubed_line, T_squared_line, color='red', linestyle='--', label=f'Fit: $T^2 = {k:.2f}r^3 + {b:.2f}$') plt.title(r\"$T^2$ vs $r^3$ for Inner Planets with Kepler's Law Line\") plt.xlabel(r\"$r^3$ (AU$^3$)\") plt.ylabel(r\"$T^2$ (years$^2$)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() Animated Orbit Visualization: Creates a dynamic representation of an object moving in a circular orbit. Helps in understanding real-time orbital mechanics. Colab Extension to Elliptical Orbits While Kepler\u2019s Third Law is derived for circular orbits, it holds for elliptical orbits as well, with the semi-major axis \\(a\\) replacing the orbital radius \\(r\\) : \\[ T^2 \\propto a^3 \\] This extends the application of the law to non-circular celestial bodies, including exoplanets, binary star systems, and asteroids. Conclusion Kepler\u2019s Third Law serves as a powerful tool in celestial mechanics, linking orbital periods and radii in a predictable manner. By leveraging computational models and real-world observations, scientists continue to explore planetary systems, enhance satellite technology, and unravel the mysteries of the universe.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#gravity-orbital-period-and-orbital-radius","text":"","title":"Gravity: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler\u2019s Third Law states that the square of the orbital period ( \\(T^2\\) ) is proportional to the cube of the orbital radius ( \\(r^3\\) ). This fundamental relationship provides critical insights into celestial mechanics, governing planetary orbits, satellite motion, and gravitational interactions on both small and cosmic scales. Understanding this law allows astronomers to determine planetary masses, calculate distances in space, and analyze the stability of orbits.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law","text":"For a body in a circular orbit around a massive central body (e.g., a planet orbiting a star), the centripetal force required to maintain the orbit is provided by gravitational attraction: \\[ F_{\\text{gravity}} = F_{\\text{centripetal}} \\] \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Since the orbital velocity \\(v\\) is related to the period \\(T\\) by: \\[ v = \\frac{2\\pi r}{T} \\] Substituting this into the equation: \\[ \\frac{G M m}{r^2} = \\frac{m (2\\pi r)^2}{T^2 r} \\] Canceling \\(m\\) and simplifying: \\[ \\frac{G M}{r^2} = \\frac{4\\pi^2 r}{T^2} \\] Rearranging: \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] This confirms that \\(T^2 \\propto r^3\\) , meaning the square of the orbital period is proportional to the cube of the orbital radius.","title":"Derivation of Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-in-astronomy","text":"Planetary Mass Calculation: Given the orbital period and radius of a planet's moon, one can estimate the planet\u2019s mass using Kepler\u2019s Law. Solar System Analysis: The law allows astronomers to determine distances between planets and their stars even without direct measurements. Satellite Orbits: Understanding this relationship helps in designing stable satellite trajectories for communication and observation. Exoplanet Detection: By measuring periodic changes in a star\u2019s brightness due to transiting planets, scientists can infer planetary orbits.","title":"Implications in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-the-moons-orbit-around-earth","text":"The Moon orbits Earth at an average radius of \\(3.84 \\times 10^5\\) km with a period of 27.3 days. Using Kepler\u2019s Law, we can estimate Earth's mass and verify astronomical models.","title":"1. The Moon\u2019s Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-the-solar-system","text":"The orbits of planets around the Sun follow Kepler\u2019s Third Law, with larger orbits corresponding to longer periods. For example: Earth: \\(r = 1\\) AU, \\(T = 1\\) year Mars: \\(r \\approx 1.52\\) AU, \\(T \\approx 1.88\\) years Jupiter: \\(r \\approx 5.2\\) AU, \\(T \\approx 11.86\\) years","title":"2. The Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#computational-simulation","text":"To visualize the orbital relationship, we employ Python simulations: Circular Orbit Simulation: Generates a circular path for an orbiting body. Marks the central mass. import matplotlib.pyplot as plt import numpy as np # Orbital period (T) in Earth years and average orbital radius (r) in AU for each planet # Data from NASA sources planets = { \"Mercury\": {\"T\": 0.240846, \"r\": 0.387}, \"Venus\": {\"T\": 0.615, \"r\": 0.723}, \"Earth\": {\"T\": 1.0, \"r\": 1.0}, \"Mars\": {\"T\": 1.881, \"r\": 1.524}, } # Calculate T^2 and r^3 for each planet T_squared = [data[\"T\"] ** 2 for data in planets.values()] r_cubed = [data[\"r\"] ** 3 for data in planets.values()] labels = list(planets.keys()) # Fit a linear regression line to the data (T^2 = k * r^3) coefficients = np.polyfit(r_cubed, T_squared, 1) k, b = coefficients # Generate line for the fit r_cubed_line = np.linspace(min(r_cubed), max(r_cubed), 100) T_squared_line = k * r_cubed_line + b # Plot the data points and the regression line plt.figure(figsize=(8, 6)) plt.scatter(r_cubed, T_squared, color='blue', label='Planets') # Add labels for each point for i, label in enumerate(labels): plt.text(r_cubed[i] + 0.005, T_squared[i], label, fontsize=9) # Plot the fitted line plt.plot(r_cubed_line, T_squared_line, color='red', linestyle='--', label=f'Fit: $T^2 = {k:.2f}r^3 + {b:.2f}$') plt.title(r\"$T^2$ vs $r^3$ for Inner Planets with Kepler's Law Line\") plt.xlabel(r\"$r^3$ (AU$^3$)\") plt.ylabel(r\"$T^2$ (years$^2$)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() Animated Orbit Visualization: Creates a dynamic representation of an object moving in a circular orbit. Helps in understanding real-time orbital mechanics. Colab","title":"Computational Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"While Kepler\u2019s Third Law is derived for circular orbits, it holds for elliptical orbits as well, with the semi-major axis \\(a\\) replacing the orbital radius \\(r\\) : \\[ T^2 \\propto a^3 \\] This extends the application of the law to non-circular celestial bodies, including exoplanets, binary star systems, and asteroids.","title":"Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler\u2019s Third Law serves as a powerful tool in celestial mechanics, linking orbital periods and radii in a predictable manner. By leveraging computational models and real-world observations, scientists continue to explore planetary systems, enhance satellite technology, and unravel the mysteries of the universe.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Motivation Understanding escape velocity and cosmic velocities is essential for grasping how spacecraft overcome gravitational pull and reach space. These velocities govern not only satellite launches but also interplanetary and interstellar missions. The first, second, and third cosmic velocities define the key thresholds for: - Staying in orbit (1st), - Escaping a planet (2nd), - Escaping a star system (3rd). 1. Cosmic Velocities Defined First Cosmic Velocity (Orbital Velocity) The minimum speed required to orbit a planet just above its surface without propulsion. $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Second Cosmic Velocity (Escape Velocity) The minimum speed needed to break free from a planet's gravitational pull. $$ v_2 = \\sqrt{2}\\cdot v_1 = \\sqrt{\\frac{2GM}{R}} $$ Third Cosmic Velocity (Interstellar Escape) The speed required to escape a star system (e.g., the Sun\u2019s gravity from Earth\u2019s orbit). $$ v_3 = \\sqrt{v_{escape,planet}^2 + v_{escape,star}^2} $$ Derivation of the Second Cosmic Velocity (Escape Velocity) The second cosmic velocity is the minimum velocity needed to escape the gravitational pull of a planet from its surface, without any further propulsion. Starting Point: Energy Conservation We use the conservation of mechanical energy: \\[ \\text{Total Energy at surface} = \\text{Total Energy at infinity} \\] At launch: Kinetic Energy: \\(\\frac{1}{2}mv^2\\) Gravitational Potential Energy: \\(-\\frac{GMm}{R}\\) At infinity: Kinetic Energy: \\(0\\) (barely escapes) Potential Energy: \\(0\\) (reference level) Set total energy at both points equal: \\[ \\frac{1}{2}mv^2 - \\frac{GMm}{R} = 0 \\] Cancel mass \\( m \\) (mass of the object), and solve for \\(v\\) : \\[ \\frac{1}{2}v^2 = \\frac{GM}{R} \\Rightarrow v = \\sqrt{\\frac{2GM}{R}} \\] Formula for Second Cosmic Velocity: \\[ v_2 = \\sqrt{\\frac{2GM}{R}} \\] This is also called the escape velocity from a planet of mass \\(M\\) and radius \\(R\\) . Derivation of the Third Cosmic Velocity (Solar System Escape) The third cosmic velocity is the minimum speed an object needs to completely escape the Sun\u2019s gravity, starting from Earth's orbit (or any planet's orbit), already moving along with that planet. Step-by-step: From a planet (e.g., Earth), you're already moving at orbital speed around the Sun due to the planet\u2019s motion. To escape the entire solar system, you need extra velocity to overcome the Sun\u2019s gravity from your current orbital distance. So the total speed required is the combination of: - The escape speed from the planet (already calculated as \\(v_2\\) ), - The additional speed needed to escape the Sun from your distance to it. Energy-Based Derivation The energy needed to escape the Sun from a planet\u2019s orbit is: \\[ \\frac{1}{2}mv^2 = \\frac{GM_{\\odot}m}{r} \\Rightarrow v_{\\text{sun\\_escape}} = \\sqrt{\\frac{2GM_{\\odot}}{r}} \\] Where: \\(M_{\\odot}\\) : Mass of the Sun \\(r\\) : Distance from the Sun (e.g., Earth\u2019s orbit: \\(1.496 \\times 10^{11} \\, \\text{m}\\) ) You already have kinetic energy from orbiting the planet, so the total speed to escape both the planet and the star is: Pythagorean Addition: \\[ v_3 = \\sqrt{v_2^2 + v_{\\text{sun\\_escape}}^2} \\] This assumes an object first escapes the planet, then immediately gains additional speed to escape the Sun in a straight-line trajectory. 2. Derivation and Parameters G = Universal Gravitational Constant $$ \\approx 6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2 $$ M = Mass of the celestial body R = Radius from the center of the celestial body These velocities increase with the mass of the body and decrease with distance. 3. Python Code and Visualization import numpy as np import matplotlib.pyplot as plt # === Constants === G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) SUN_MASS = 1.989e30 # mass of the Sun (kg) # === Planetary data: mass (kg), radius (m), average distance from Sun (m) === bodies = { 'Mercury': {'mass': 3.301e23, 'radius': 2.4397e6, 'sun_dist': 5.791e10}, 'Venus': {'mass': 4.867e24, 'radius': 6.0518e6, 'sun_dist': 1.082e11}, 'Earth': {'mass': 5.972e24, 'radius': 6.371e6, 'sun_dist': 1.496e11}, 'Mars': {'mass': 6.39e23, 'radius': 3.3895e6, 'sun_dist': 2.279e11}, 'Jupiter': {'mass': 1.898e27, 'radius': 6.9911e7, 'sun_dist': 7.785e11}, 'Saturn': {'mass': 5.683e26, 'radius': 5.8232e7, 'sun_dist': 1.433e12} } # === Velocity calculations === def compute_cosmic_velocities(planet_mass, planet_radius, dist_to_sun): \"\"\" Compute the three main cosmic velocities: - v1: Orbital velocity around planet (1st cosmic velocity) - v2: Escape velocity from planet (2nd cosmic velocity) - v3: Escape velocity from the solar system at planet's orbit (3rd cosmic velocity) Returns velocities in km/s. \"\"\" v1 = np.sqrt(G * planet_mass / planet_radius) # 1st cosmic v2 = np.sqrt(2 * G * planet_mass / planet_radius) # 2nd cosmic v_sun_escape = np.sqrt(2 * G * SUN_MASS / dist_to_sun) # solar system escape v3 = np.sqrt(v2**2 + v_sun_escape**2) # 3rd cosmic (combined escape) return v1 / 1000, v2 / 1000, v3 / 1000 # Convert to km/s # === Data processing === results = { planet: compute_cosmic_velocities(data['mass'], data['radius'], data['sun_dist']) for planet, data in bodies.items() } # === Plotting data === labels = list(results.keys()) v1_vals = [results[p][0] for p in labels] v2_vals = [results[p][1] for p in labels] v3_vals = [results[p][2] for p in labels] x = np.arange(len(labels)) bar_width = 0.25 # === Plotting === plt.figure(figsize=(12, 7)) colors = ['#4e79a7', '#f28e2b', '#e15759'] bars1 = plt.bar(x - bar_width, v1_vals, width=bar_width, label='1st Cosmic (Orbital)', color=colors[0]) bars2 = plt.bar(x, v2_vals, width=bar_width, label='2nd Cosmic (Escape)', color=colors[1]) bars3 = plt.bar(x + bar_width, v3_vals, width=bar_width, label='3rd Cosmic (Solar Escape)', color=colors[2]) # === Annotate bar values === for bar_group in [bars1, bars2, bars3]: for bar in bar_group: height = bar.get_height() plt.text(bar.get_x() + bar.get_width() / 2, height + 0.4, f\"{height:.1f}\", ha='center', va='bottom', fontsize=8) # === Plot settings === plt.xticks(x, labels, fontsize=10) plt.ylabel(\"Velocity (km/s)\", fontsize=12) plt.title(\"Cosmic Velocities for Planets in the Solar System\", fontsize=14, fontweight='bold') plt.legend() plt.grid(True, linestyle='--', alpha=0.4) plt.tight_layout() plt.show() Colab 4. Discussion and Importance in Space Exploration First Cosmic Velocity Enables satellites to orbit Earth or other planets. Used in designing stable, fuel-efficient orbits for communication, navigation, and observation. Second Cosmic Velocity Critical for launching missions beyond Earth (e.g., Mars rovers). Requires powerful boosters like the Saturn V or SLS. Third Cosmic Velocity Needed for escaping the Sun\u2019s gravitational field. Applied in deep space missions (e.g., Voyager, New Horizons). Achievable with gravity assists or long-duration ion drives. Conclusion The concept of cosmic velocities illustrates the increasing energy requirements for moving from orbit to planetary escape to interstellar travel. These velocities are fundamental in space mission planning and dictate the technology and fuel necessary for different levels of exploration. As we aim for Mars and beyond, mastering these speeds becomes ever more crucial.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"Understanding escape velocity and cosmic velocities is essential for grasping how spacecraft overcome gravitational pull and reach space. These velocities govern not only satellite launches but also interplanetary and interstellar missions. The first, second, and third cosmic velocities define the key thresholds for: - Staying in orbit (1st), - Escaping a planet (2nd), - Escaping a star system (3rd).","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-cosmic-velocities-defined","text":"","title":"1. Cosmic Velocities Defined"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-orbital-velocity","text":"The minimum speed required to orbit a planet just above its surface without propulsion. $$ v_1 = \\sqrt{\\frac{GM}{R}} $$","title":"First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity","text":"The minimum speed needed to break free from a planet's gravitational pull. $$ v_2 = \\sqrt{2}\\cdot v_1 = \\sqrt{\\frac{2GM}{R}} $$","title":"Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-interstellar-escape","text":"The speed required to escape a star system (e.g., the Sun\u2019s gravity from Earth\u2019s orbit). $$ v_3 = \\sqrt{v_{escape,planet}^2 + v_{escape,star}^2} $$","title":"Third Cosmic Velocity (Interstellar Escape)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#derivation-of-the-second-cosmic-velocity-escape-velocity","text":"The second cosmic velocity is the minimum velocity needed to escape the gravitational pull of a planet from its surface, without any further propulsion.","title":"Derivation of the Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#starting-point-energy-conservation","text":"We use the conservation of mechanical energy: \\[ \\text{Total Energy at surface} = \\text{Total Energy at infinity} \\] At launch: Kinetic Energy: \\(\\frac{1}{2}mv^2\\) Gravitational Potential Energy: \\(-\\frac{GMm}{R}\\) At infinity: Kinetic Energy: \\(0\\) (barely escapes) Potential Energy: \\(0\\) (reference level) Set total energy at both points equal: \\[ \\frac{1}{2}mv^2 - \\frac{GMm}{R} = 0 \\] Cancel mass \\( m \\) (mass of the object), and solve for \\(v\\) : \\[ \\frac{1}{2}v^2 = \\frac{GM}{R} \\Rightarrow v = \\sqrt{\\frac{2GM}{R}} \\]","title":"Starting Point: Energy Conservation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#formula-for-second-cosmic-velocity","text":"\\[ v_2 = \\sqrt{\\frac{2GM}{R}} \\] This is also called the escape velocity from a planet of mass \\(M\\) and radius \\(R\\) .","title":"Formula for Second Cosmic Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#derivation-of-the-third-cosmic-velocity-solar-system-escape","text":"The third cosmic velocity is the minimum speed an object needs to completely escape the Sun\u2019s gravity, starting from Earth's orbit (or any planet's orbit), already moving along with that planet.","title":"Derivation of the Third Cosmic Velocity (Solar System Escape)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#step-by-step","text":"From a planet (e.g., Earth), you're already moving at orbital speed around the Sun due to the planet\u2019s motion. To escape the entire solar system, you need extra velocity to overcome the Sun\u2019s gravity from your current orbital distance. So the total speed required is the combination of: - The escape speed from the planet (already calculated as \\(v_2\\) ), - The additional speed needed to escape the Sun from your distance to it.","title":"Step-by-step:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#energy-based-derivation","text":"The energy needed to escape the Sun from a planet\u2019s orbit is: \\[ \\frac{1}{2}mv^2 = \\frac{GM_{\\odot}m}{r} \\Rightarrow v_{\\text{sun\\_escape}} = \\sqrt{\\frac{2GM_{\\odot}}{r}} \\] Where: \\(M_{\\odot}\\) : Mass of the Sun \\(r\\) : Distance from the Sun (e.g., Earth\u2019s orbit: \\(1.496 \\times 10^{11} \\, \\text{m}\\) ) You already have kinetic energy from orbiting the planet, so the total speed to escape both the planet and the star is:","title":"Energy-Based Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#pythagorean-addition","text":"\\[ v_3 = \\sqrt{v_2^2 + v_{\\text{sun\\_escape}}^2} \\] This assumes an object first escapes the planet, then immediately gains additional speed to escape the Sun in a straight-line trajectory.","title":"Pythagorean Addition:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-derivation-and-parameters","text":"G = Universal Gravitational Constant $$ \\approx 6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2 $$ M = Mass of the celestial body R = Radius from the center of the celestial body These velocities increase with the mass of the body and decrease with distance.","title":"2. Derivation and Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-python-code-and-visualization","text":"import numpy as np import matplotlib.pyplot as plt # === Constants === G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) SUN_MASS = 1.989e30 # mass of the Sun (kg) # === Planetary data: mass (kg), radius (m), average distance from Sun (m) === bodies = { 'Mercury': {'mass': 3.301e23, 'radius': 2.4397e6, 'sun_dist': 5.791e10}, 'Venus': {'mass': 4.867e24, 'radius': 6.0518e6, 'sun_dist': 1.082e11}, 'Earth': {'mass': 5.972e24, 'radius': 6.371e6, 'sun_dist': 1.496e11}, 'Mars': {'mass': 6.39e23, 'radius': 3.3895e6, 'sun_dist': 2.279e11}, 'Jupiter': {'mass': 1.898e27, 'radius': 6.9911e7, 'sun_dist': 7.785e11}, 'Saturn': {'mass': 5.683e26, 'radius': 5.8232e7, 'sun_dist': 1.433e12} } # === Velocity calculations === def compute_cosmic_velocities(planet_mass, planet_radius, dist_to_sun): \"\"\" Compute the three main cosmic velocities: - v1: Orbital velocity around planet (1st cosmic velocity) - v2: Escape velocity from planet (2nd cosmic velocity) - v3: Escape velocity from the solar system at planet's orbit (3rd cosmic velocity) Returns velocities in km/s. \"\"\" v1 = np.sqrt(G * planet_mass / planet_radius) # 1st cosmic v2 = np.sqrt(2 * G * planet_mass / planet_radius) # 2nd cosmic v_sun_escape = np.sqrt(2 * G * SUN_MASS / dist_to_sun) # solar system escape v3 = np.sqrt(v2**2 + v_sun_escape**2) # 3rd cosmic (combined escape) return v1 / 1000, v2 / 1000, v3 / 1000 # Convert to km/s # === Data processing === results = { planet: compute_cosmic_velocities(data['mass'], data['radius'], data['sun_dist']) for planet, data in bodies.items() } # === Plotting data === labels = list(results.keys()) v1_vals = [results[p][0] for p in labels] v2_vals = [results[p][1] for p in labels] v3_vals = [results[p][2] for p in labels] x = np.arange(len(labels)) bar_width = 0.25 # === Plotting === plt.figure(figsize=(12, 7)) colors = ['#4e79a7', '#f28e2b', '#e15759'] bars1 = plt.bar(x - bar_width, v1_vals, width=bar_width, label='1st Cosmic (Orbital)', color=colors[0]) bars2 = plt.bar(x, v2_vals, width=bar_width, label='2nd Cosmic (Escape)', color=colors[1]) bars3 = plt.bar(x + bar_width, v3_vals, width=bar_width, label='3rd Cosmic (Solar Escape)', color=colors[2]) # === Annotate bar values === for bar_group in [bars1, bars2, bars3]: for bar in bar_group: height = bar.get_height() plt.text(bar.get_x() + bar.get_width() / 2, height + 0.4, f\"{height:.1f}\", ha='center', va='bottom', fontsize=8) # === Plot settings === plt.xticks(x, labels, fontsize=10) plt.ylabel(\"Velocity (km/s)\", fontsize=12) plt.title(\"Cosmic Velocities for Planets in the Solar System\", fontsize=14, fontweight='bold') plt.legend() plt.grid(True, linestyle='--', alpha=0.4) plt.tight_layout() plt.show() Colab","title":"3. Python Code and Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-discussion-and-importance-in-space-exploration","text":"","title":"4. Discussion and Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity","text":"Enables satellites to orbit Earth or other planets. Used in designing stable, fuel-efficient orbits for communication, navigation, and observation.","title":"First Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity","text":"Critical for launching missions beyond Earth (e.g., Mars rovers). Requires powerful boosters like the Saturn V or SLS.","title":"Second Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity","text":"Needed for escaping the Sun\u2019s gravitational field. Applied in deep space missions (e.g., Voyager, New Horizons). Achievable with gravity assists or long-duration ion drives.","title":"Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#conclusion","text":"The concept of cosmic velocities illustrates the increasing energy requirements for moving from orbit to planetary escape to interstellar travel. These velocities are fundamental in space mission planning and dictate the technology and fuel necessary for different levels of exploration. As we aim for Mars and beyond, mastering these speeds becomes ever more crucial.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Motivation When an object is released from a moving rocket near Earth, its trajectory is governed by gravitational forces and the object's initial velocity. This forms a critical area of study in orbital mechanics and is essential for space mission planning. Understanding these trajectories informs strategies for satellite deployment, payload insertion into orbit, and reentry or escape from Earth's gravitational influence. Theoretical Background Newton's Law of Gravitation The force acting on a payload of mass \\(m\\) due to Earth (mass \\(M\\) ) at a distance \\(r\\) from Earth's center is: \\(F = \\frac{GMm}{r^2}\\) where \\(G\\) is the gravitational constant. Equation of Motion Using Newton's second law: \\(m\\ddot{\\mathbf{r}} = -\\frac{GMm}{r^3} \\mathbf{r}\\) \\(\\Rightarrow \\ddot{\\mathbf{r}} = -\\frac{GM}{r^3} \\mathbf{r}\\) This differential equation governs the acceleration of the payload under gravity. Kepler\u2019s Laws of Orbital Motion First Law: Planets (and payloads) move in ellipses with the Earth at one focus. Second Law: A line connecting the payload and Earth sweeps equal areas in equal times. Third Law: The square of the orbital period is proportional to the cube of the semi-major axis. These laws provide insight into the shapes and timings of orbits resulting from different initial conditions. Types of Trajectories Elliptical : \\(0 < e < 1\\) \u2013 bound orbits. Parabolic : \\(e = 1\\) \u2013 escape at exact escape velocity. Hyperbolic : \\(e > 1\\) \u2013 escape trajectory with excess velocity. Circular : Special case of elliptical orbit when eccentricity \\(e = 0\\) . Numerical Simulation Python and numerical integration methods (e.g., Runge-Kutta) are used to simulate motion. Simulations include various initial conditions: - Velocity below orbital speed (leading to reentry) - Velocity equal to orbital speed (leading to stable orbit) - Velocity above escape speed (leading to hyperbolic escape) The simulation visualizes: - Trajectories in 2D/3D space - Velocity and altitude over time - Comparison of orbital types import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # gravitational constant M = 5.972e24 # mass of Earth R_earth = 6.371e6 # Earth's radius (m) # Initial conditions x0, y0 = R_earth + 300e3, 0 # start 300 km above Earth's surface t_span = (0, 10000) t_eval = np.linspace(*t_span, 1000) initial_velocities = [6000, 7700, 11000] # m/s colors = ['red', 'blue', 'green'] labels = ['Reentry', 'Stable Orbit', 'Escape'] # Gravitational acceleration def gravity(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] # Event: stop if hitting Earth def hit_earth(t, state): x, y = state[0], state[1] return np.sqrt(x**2 + y**2) - R_earth hit_earth.terminal = True hit_earth.direction = -1 # Plot setup plt.figure(figsize=(8, 8)) # Plot trajectories for vy0, color, label in zip(initial_velocities, colors, labels): initial_state = [x0, y0, 0, vy0] sol = solve_ivp(gravity, t_span, initial_state, t_eval=t_eval, rtol=1e-8, events=hit_earth) plt.plot(sol.y[0], sol.y[1], color=color, label=label) # Draw Earth as a true-size circle earth_circle = plt.Circle((0, 0), R_earth, color='deepskyblue', ec='k', zorder=0) plt.gca().add_artist(earth_circle) # Final touches plt.gca().set_aspect('equal', adjustable='box') plt.title('Trajectory Comparison: Reentry vs Orbit vs Escape') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.legend() plt.grid(True) # Zoom out enough to see trajectories and Earth properly plt.xlim(-1.5e7, 1.5e7) plt.ylim(-1.5e7, 1.5e7) plt.show() import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # gravitational constant, m^3/kg/s^2 M = 5.972e24 # mass of Earth, kg R_earth = 6.371e6 # radius of Earth, m # Gravitational acceleration function def gravity(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] # Stop when hitting the Earth def hit_earth(t, state): x, y = state[0], state[1] return np.sqrt(x**2 + y**2) - R_earth hit_earth.terminal = True hit_earth.direction = -1 # Initial position: 800 km above Earth's surface on the x-axis altitude = 800e3 # 800 km x0 = R_earth + altitude y0 = 0 vx0 = 0 # Time parameters t_span = (0, 20000) # seconds t_eval = np.linspace(*t_span, 2000) # Initial velocities in m/s velocities = np.arange(5000, 13500, 500) # from 5 km/s to 13 km/s colors = plt.cm.viridis(np.linspace(0, 1, len(velocities))) # Plot setup plt.figure(figsize=(10, 10)) # Plot Earth earth = plt.Circle((0, 0), R_earth, color='blue', alpha=0.3, label='Earth') plt.gca().add_patch(earth) # Plot trajectories for each initial velocity for v, color in zip(velocities, colors): initial_state = [x0, y0, 0, v] sol = solve_ivp(gravity, t_span, initial_state, t_eval=t_eval, rtol=1e-8, events=hit_earth) plt.plot(sol.y[0], sol.y[1], color=color, label=f'{v/1000:.1f} km/s') # Final plot touches plt.plot(0, 0, 'ko', label='Center of Earth') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Trajectories from 800 km Altitude at Various Velocities') plt.gca().set_aspect('equal', adjustable='box') plt.grid(True) plt.legend(loc='upper right', bbox_to_anchor=(1.3, 1.0)) plt.tight_layout() plt.show() Computational Tool A Python notebook is developed using libraries such as NumPy, SciPy, and Matplotlib: User inputs initial position and velocity. Gravitational acceleration is computed. Time integration is performed using ODE solvers. Trajectories are plotted dynamically. import numpy as np from scipy.integrate import solve_ivp import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant M = 5.972e24 # mass of Earth R_earth = 6.371e6 # radius of Earth # Gravitational acceleration def gravity(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] # Stop if hitting Earth def hit_earth(t, state): x, y = state[0], state[1] return np.sqrt(x**2 + y**2) - R_earth hit_earth.terminal = True hit_earth.direction = -1 # Initial conditions x0 = R_earth + 400e3 # 400 km altitude y0 = 0 vx0 = 0 vy0 = 7700 # LEO speed in m/s initial_state = [x0, y0, vx0, vy0] # Time span t_span = (0, 6000) t_eval = np.linspace(*t_span, 1000) # Solve the trajectory solution = solve_ivp(gravity, t_span, initial_state, t_eval=t_eval, rtol=1e-8, events=hit_earth) # Plotting plt.figure(figsize=(8, 8)) # Plot trajectory plt.plot(solution.y[0], solution.y[1], label='Payload Path') # Draw Earth as a circle earth = plt.Circle((0, 0), R_earth, color='skyblue', ec='k', zorder=0) plt.gca().add_artist(earth) # Plot settings plt.gca().set_aspect('equal', adjustable='box') plt.title('Payload Trajectory') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.legend() plt.grid(True) # Adjust view to fit trajectory and Earth buffer = 1.2 * (R_earth + 500e3) plt.xlim(-buffer, buffer) plt.ylim(-buffer, buffer) plt.show() Real-World Applications Orbital Insertion : Choosing correct velocity and direction ensures desired orbit. Reentry : Predicting where and when a payload returns to Earth. Escape Trajectories : Calculating minimal velocity for leaving Earth\u2019s gravity. Mission Planning : Used by space agencies to plan satellite launches and planetary missions. Deliverables A Python notebook with simulation and visualization. Markdown documentation explaining theoretical background and simulation approach. Graphical results showing different trajectory types based on input conditions. Conclusion By understanding and simulating the gravitational motion of payloads released near Earth, engineers and scientists can better plan space missions and predict payload behavior. This analysis merges classical mechanics with computational tools to solve real-world problems in space exploration.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory is governed by gravitational forces and the object's initial velocity. This forms a critical area of study in orbital mechanics and is essential for space mission planning. Understanding these trajectories informs strategies for satellite deployment, payload insertion into orbit, and reentry or escape from Earth's gravitational influence.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-background","text":"","title":"Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-law-of-gravitation","text":"The force acting on a payload of mass \\(m\\) due to Earth (mass \\(M\\) ) at a distance \\(r\\) from Earth's center is: \\(F = \\frac{GMm}{r^2}\\) where \\(G\\) is the gravitational constant.","title":"Newton's Law of Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#equation-of-motion","text":"Using Newton's second law: \\(m\\ddot{\\mathbf{r}} = -\\frac{GMm}{r^3} \\mathbf{r}\\) \\(\\Rightarrow \\ddot{\\mathbf{r}} = -\\frac{GM}{r^3} \\mathbf{r}\\) This differential equation governs the acceleration of the payload under gravity. Kepler\u2019s Laws of Orbital Motion First Law: Planets (and payloads) move in ellipses with the Earth at one focus. Second Law: A line connecting the payload and Earth sweeps equal areas in equal times. Third Law: The square of the orbital period is proportional to the cube of the semi-major axis. These laws provide insight into the shapes and timings of orbits resulting from different initial conditions.","title":"Equation of Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-trajectories","text":"Elliptical : \\(0 < e < 1\\) \u2013 bound orbits. Parabolic : \\(e = 1\\) \u2013 escape at exact escape velocity. Hyperbolic : \\(e > 1\\) \u2013 escape trajectory with excess velocity. Circular : Special case of elliptical orbit when eccentricity \\(e = 0\\) .","title":"Types of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-simulation","text":"Python and numerical integration methods (e.g., Runge-Kutta) are used to simulate motion. Simulations include various initial conditions: - Velocity below orbital speed (leading to reentry) - Velocity equal to orbital speed (leading to stable orbit) - Velocity above escape speed (leading to hyperbolic escape) The simulation visualizes: - Trajectories in 2D/3D space - Velocity and altitude over time - Comparison of orbital types import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # gravitational constant M = 5.972e24 # mass of Earth R_earth = 6.371e6 # Earth's radius (m) # Initial conditions x0, y0 = R_earth + 300e3, 0 # start 300 km above Earth's surface t_span = (0, 10000) t_eval = np.linspace(*t_span, 1000) initial_velocities = [6000, 7700, 11000] # m/s colors = ['red', 'blue', 'green'] labels = ['Reentry', 'Stable Orbit', 'Escape'] # Gravitational acceleration def gravity(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] # Event: stop if hitting Earth def hit_earth(t, state): x, y = state[0], state[1] return np.sqrt(x**2 + y**2) - R_earth hit_earth.terminal = True hit_earth.direction = -1 # Plot setup plt.figure(figsize=(8, 8)) # Plot trajectories for vy0, color, label in zip(initial_velocities, colors, labels): initial_state = [x0, y0, 0, vy0] sol = solve_ivp(gravity, t_span, initial_state, t_eval=t_eval, rtol=1e-8, events=hit_earth) plt.plot(sol.y[0], sol.y[1], color=color, label=label) # Draw Earth as a true-size circle earth_circle = plt.Circle((0, 0), R_earth, color='deepskyblue', ec='k', zorder=0) plt.gca().add_artist(earth_circle) # Final touches plt.gca().set_aspect('equal', adjustable='box') plt.title('Trajectory Comparison: Reentry vs Orbit vs Escape') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.legend() plt.grid(True) # Zoom out enough to see trajectories and Earth properly plt.xlim(-1.5e7, 1.5e7) plt.ylim(-1.5e7, 1.5e7) plt.show() import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # gravitational constant, m^3/kg/s^2 M = 5.972e24 # mass of Earth, kg R_earth = 6.371e6 # radius of Earth, m # Gravitational acceleration function def gravity(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] # Stop when hitting the Earth def hit_earth(t, state): x, y = state[0], state[1] return np.sqrt(x**2 + y**2) - R_earth hit_earth.terminal = True hit_earth.direction = -1 # Initial position: 800 km above Earth's surface on the x-axis altitude = 800e3 # 800 km x0 = R_earth + altitude y0 = 0 vx0 = 0 # Time parameters t_span = (0, 20000) # seconds t_eval = np.linspace(*t_span, 2000) # Initial velocities in m/s velocities = np.arange(5000, 13500, 500) # from 5 km/s to 13 km/s colors = plt.cm.viridis(np.linspace(0, 1, len(velocities))) # Plot setup plt.figure(figsize=(10, 10)) # Plot Earth earth = plt.Circle((0, 0), R_earth, color='blue', alpha=0.3, label='Earth') plt.gca().add_patch(earth) # Plot trajectories for each initial velocity for v, color in zip(velocities, colors): initial_state = [x0, y0, 0, v] sol = solve_ivp(gravity, t_span, initial_state, t_eval=t_eval, rtol=1e-8, events=hit_earth) plt.plot(sol.y[0], sol.y[1], color=color, label=f'{v/1000:.1f} km/s') # Final plot touches plt.plot(0, 0, 'ko', label='Center of Earth') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Trajectories from 800 km Altitude at Various Velocities') plt.gca().set_aspect('equal', adjustable='box') plt.grid(True) plt.legend(loc='upper right', bbox_to_anchor=(1.3, 1.0)) plt.tight_layout() plt.show()","title":"Numerical Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#computational-tool","text":"A Python notebook is developed using libraries such as NumPy, SciPy, and Matplotlib: User inputs initial position and velocity. Gravitational acceleration is computed. Time integration is performed using ODE solvers. Trajectories are plotted dynamically. import numpy as np from scipy.integrate import solve_ivp import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant M = 5.972e24 # mass of Earth R_earth = 6.371e6 # radius of Earth # Gravitational acceleration def gravity(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] # Stop if hitting Earth def hit_earth(t, state): x, y = state[0], state[1] return np.sqrt(x**2 + y**2) - R_earth hit_earth.terminal = True hit_earth.direction = -1 # Initial conditions x0 = R_earth + 400e3 # 400 km altitude y0 = 0 vx0 = 0 vy0 = 7700 # LEO speed in m/s initial_state = [x0, y0, vx0, vy0] # Time span t_span = (0, 6000) t_eval = np.linspace(*t_span, 1000) # Solve the trajectory solution = solve_ivp(gravity, t_span, initial_state, t_eval=t_eval, rtol=1e-8, events=hit_earth) # Plotting plt.figure(figsize=(8, 8)) # Plot trajectory plt.plot(solution.y[0], solution.y[1], label='Payload Path') # Draw Earth as a circle earth = plt.Circle((0, 0), R_earth, color='skyblue', ec='k', zorder=0) plt.gca().add_artist(earth) # Plot settings plt.gca().set_aspect('equal', adjustable='box') plt.title('Payload Trajectory') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.legend() plt.grid(True) # Adjust view to fit trajectory and Earth buffer = 1.2 * (R_earth + 500e3) plt.xlim(-buffer, buffer) plt.ylim(-buffer, buffer) plt.show()","title":"Computational Tool"},{"location":"1%20Physics/2%20Gravity/Problem_3/#real-world-applications","text":"Orbital Insertion : Choosing correct velocity and direction ensures desired orbit. Reentry : Predicting where and when a payload returns to Earth. Escape Trajectories : Calculating minimal velocity for leaving Earth\u2019s gravity. Mission Planning : Used by space agencies to plan satellite launches and planetary missions.","title":"Real-World Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#deliverables","text":"A Python notebook with simulation and visualization. Markdown documentation explaining theoretical background and simulation approach. Graphical results showing different trajectory types based on input conditions.","title":"Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"By understanding and simulating the gravitational motion of payloads released near Earth, engineers and scientists can better plan space missions and predict payload behavior. This analysis merges classical mechanics with computational tools to solve real-world problems in space exploration.","title":"Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a Water Surface 1. Motivation Interference occurs when waves from different sources overlap, creating new patterns of constructive and destructive interference. This is particularly visible on water surfaces, where ripples intersect and produce easily observable effects. By analyzing interference patterns, we gain insight into fundamental wave behavior \u2014 such as superposition, phase relationships, and coherence. This experiment provides a visual and intuitive understanding of these concepts using water waves, making it an engaging introduction to wave physics. 2. Task Overview To study interference patterns, we will simulate circular waves emitted from point sources placed at the vertices of a regular polygon. We will: Choose a regular polygon. Model each wave mathematically. Superimpose the waves. Visualize the resulting interference pattern. Analyze regions of constructive and destructive interference. 3. Mathematical Background Single Wave Equation A circular wave on the water surface from a point source at position \\( \\((x_i, y_i)\\) \\) is described as: \\[ \\eta_i(x, y, t) = A \\cos(k r_i - \\omega t + \\phi) \\] Where: \\(\\eta_i(x, y, t)\\) is the displacement of the water surface from source \\(i\\) \\(A\\) is the amplitude \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number \\(\\omega = 2\\pi f\\) is the angular frequency \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) is the distance from the source \\(\\phi\\) is the initial phase (assumed 0 for all sources) Superposition Principle The total displacement at point \\((x, y)\\) and time \\(t\\) is: \\(\\eta(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t)\\) Where \\(N\\) is the number of sources. 4. Implementation in Python import numpy as np import matplotlib.pyplot as plt # Parameters A = 1 # Amplitude wavelength = 2 # Wavelength frequency = 1 # Frequency (Hz) omega = 2 * np.pi * frequency k = 2 * np.pi / wavelength phi = 0 # Initial phase N = 5 # Number of sources (e.g., regular pentagon) radius = 5 # Radius of the polygon t = 0 # Snapshot at time t = 0 # Grid for visualization x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # Source positions at the vertices of a regular polygon angles = np.linspace(0, 2 * np.pi, N, endpoint=False) source_positions = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Calculate wave superposition eta = np.zeros_like(X) for (xi, yi) in source_positions: r = np.sqrt((X - xi)**2 + (Y - yi)**2) eta += A * np.cos(k * r - omega * t + phi) # Plot plt.figure(figsize=(8, 8)) plt.contourf(X, Y, eta, levels=100, cmap='coolwarm') plt.colorbar(label='Displacement') plt.title(f'Interference Pattern from {N}-Source Polygon (Regular Pentagon)') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.grid(False) plt.show() import numpy as np import matplotlib.pyplot as plt # Create a grid x = np.linspace(-10, 10, 400) y = np.linspace(-10, 10, 400) X, Y = np.meshgrid(x, y) R = np.sqrt(X**2 + Y**2) # Create wave pattern Z = np.sin(5 * R) / (R + 1e-6) # Plot and save heatmap plt.figure(figsize=(6, 5)) plt.title(\"Wave Heatmap\") plt.imshow(Z, extent=(-10, 10, -10, 10), cmap='coolwarm', origin='lower') plt.colorbar(label='Amplitude') plt.xlabel('x') plt.ylabel('y') plt.grid(False) plt.tight_layout() plt.savefig(\"wave_heatmap.png\", dpi=300) plt.show() import numpy as np import matplotlib.pyplot as plt # Create a grid x = np.linspace(-10, 10, 400) y = np.linspace(-10, 10, 400) X, Y = np.meshgrid(x, y) R = np.sqrt(X**2 + Y**2) # Create wave pattern Z = np.sin(5 * R) / (R + 1e-6) # Plot and save heatmap plt.figure(figsize=(6, 5)) plt.title(\"Wave Heatmap\") plt.imshow(Z, extent=(-10, 10, -10, 10), cmap='coolwarm', origin='lower') plt.colorbar(label='Amplitude') plt.xlabel('x') plt.ylabel('y') plt.grid(False) plt.tight_layout() plt.savefig(\"wave_heatmap.png\", dpi=300) plt.show() import numpy as np import matplotlib.pyplot as plt # Create a grid x = np.linspace(-10, 10, 400) y = np.linspace(-10, 10, 400) X, Y = np.meshgrid(x, y) R = np.sqrt(X**2 + Y**2) # Create wave pattern Z = np.sin(5 * R) / (R + 1e-6) # Plot and save heatmap plt.figure(figsize=(6, 5)) plt.title(\"Wave Heatmap\") plt.imshow(Z, extent=(-10, 10, -10, 10), cmap='coolwarm', origin='lower') plt.colorbar(label='Amplitude') plt.xlabel('x') plt.ylabel('y') plt.grid(False) plt.tight_layout() plt.savefig(\"wave_heatmap.png\", dpi=300) plt.show() import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Create a grid x = np.linspace(-10, 10, 400) y = np.linspace(-10, 10, 400) X, Y = np.meshgrid(x, y) R = np.sqrt(X**2 + Y**2) # Create wave pattern Z = np.sin(5 * R) / (R + 1e-6) # Plot and save 3D surface fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(X, Y, Z, cmap='viridis', edgecolor='none') ax.set_title('3D Wave Plot from Single Source') ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_zlabel('Amplitude') plt.tight_layout() plt.savefig(\"wave_3d_surface.png\", dpi=300) plt.show() 5. Observations and Analysis Constructive Interference: Occurs where wave crests align, increasing amplitude. These appear as ridges or bright bands in the plot. Destructive Interference: Occurs where a crest meets a trough, canceling out. These are shown as flat (dark) regions. Symmetry: Due to the regular polygon setup and equal wave properties, the interference pattern is symmetrical, matching the geometry of the polygon. The complexity of the pattern increases with the number of sources, leading to denser interference zones. 6. Conclusion This simulation demonstrates the power of superposition in wave physics. By modeling water wave interference from a regular polygon arrangement, we observe both constructive and destructive interference in a visually striking and symmetric pattern. This exercise reinforces key wave principles and highlights the utility of simulation in physics education.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-motivation","text":"Interference occurs when waves from different sources overlap, creating new patterns of constructive and destructive interference. This is particularly visible on water surfaces, where ripples intersect and produce easily observable effects. By analyzing interference patterns, we gain insight into fundamental wave behavior \u2014 such as superposition, phase relationships, and coherence. This experiment provides a visual and intuitive understanding of these concepts using water waves, making it an engaging introduction to wave physics.","title":"1. Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-task-overview","text":"To study interference patterns, we will simulate circular waves emitted from point sources placed at the vertices of a regular polygon. We will: Choose a regular polygon. Model each wave mathematically. Superimpose the waves. Visualize the resulting interference pattern. Analyze regions of constructive and destructive interference.","title":"2. Task Overview"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-mathematical-background","text":"","title":"3. Mathematical Background"},{"location":"1%20Physics/3%20Waves/Problem_1/#single-wave-equation","text":"A circular wave on the water surface from a point source at position \\( \\((x_i, y_i)\\) \\) is described as: \\[ \\eta_i(x, y, t) = A \\cos(k r_i - \\omega t + \\phi) \\] Where: \\(\\eta_i(x, y, t)\\) is the displacement of the water surface from source \\(i\\) \\(A\\) is the amplitude \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number \\(\\omega = 2\\pi f\\) is the angular frequency \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) is the distance from the source \\(\\phi\\) is the initial phase (assumed 0 for all sources)","title":"Single Wave Equation"},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-principle","text":"The total displacement at point \\((x, y)\\) and time \\(t\\) is: \\(\\eta(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t)\\) Where \\(N\\) is the number of sources.","title":"Superposition Principle"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-implementation-in-python","text":"import numpy as np import matplotlib.pyplot as plt # Parameters A = 1 # Amplitude wavelength = 2 # Wavelength frequency = 1 # Frequency (Hz) omega = 2 * np.pi * frequency k = 2 * np.pi / wavelength phi = 0 # Initial phase N = 5 # Number of sources (e.g., regular pentagon) radius = 5 # Radius of the polygon t = 0 # Snapshot at time t = 0 # Grid for visualization x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # Source positions at the vertices of a regular polygon angles = np.linspace(0, 2 * np.pi, N, endpoint=False) source_positions = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Calculate wave superposition eta = np.zeros_like(X) for (xi, yi) in source_positions: r = np.sqrt((X - xi)**2 + (Y - yi)**2) eta += A * np.cos(k * r - omega * t + phi) # Plot plt.figure(figsize=(8, 8)) plt.contourf(X, Y, eta, levels=100, cmap='coolwarm') plt.colorbar(label='Displacement') plt.title(f'Interference Pattern from {N}-Source Polygon (Regular Pentagon)') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.grid(False) plt.show() import numpy as np import matplotlib.pyplot as plt # Create a grid x = np.linspace(-10, 10, 400) y = np.linspace(-10, 10, 400) X, Y = np.meshgrid(x, y) R = np.sqrt(X**2 + Y**2) # Create wave pattern Z = np.sin(5 * R) / (R + 1e-6) # Plot and save heatmap plt.figure(figsize=(6, 5)) plt.title(\"Wave Heatmap\") plt.imshow(Z, extent=(-10, 10, -10, 10), cmap='coolwarm', origin='lower') plt.colorbar(label='Amplitude') plt.xlabel('x') plt.ylabel('y') plt.grid(False) plt.tight_layout() plt.savefig(\"wave_heatmap.png\", dpi=300) plt.show() import numpy as np import matplotlib.pyplot as plt # Create a grid x = np.linspace(-10, 10, 400) y = np.linspace(-10, 10, 400) X, Y = np.meshgrid(x, y) R = np.sqrt(X**2 + Y**2) # Create wave pattern Z = np.sin(5 * R) / (R + 1e-6) # Plot and save heatmap plt.figure(figsize=(6, 5)) plt.title(\"Wave Heatmap\") plt.imshow(Z, extent=(-10, 10, -10, 10), cmap='coolwarm', origin='lower') plt.colorbar(label='Amplitude') plt.xlabel('x') plt.ylabel('y') plt.grid(False) plt.tight_layout() plt.savefig(\"wave_heatmap.png\", dpi=300) plt.show() import numpy as np import matplotlib.pyplot as plt # Create a grid x = np.linspace(-10, 10, 400) y = np.linspace(-10, 10, 400) X, Y = np.meshgrid(x, y) R = np.sqrt(X**2 + Y**2) # Create wave pattern Z = np.sin(5 * R) / (R + 1e-6) # Plot and save heatmap plt.figure(figsize=(6, 5)) plt.title(\"Wave Heatmap\") plt.imshow(Z, extent=(-10, 10, -10, 10), cmap='coolwarm', origin='lower') plt.colorbar(label='Amplitude') plt.xlabel('x') plt.ylabel('y') plt.grid(False) plt.tight_layout() plt.savefig(\"wave_heatmap.png\", dpi=300) plt.show() import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Create a grid x = np.linspace(-10, 10, 400) y = np.linspace(-10, 10, 400) X, Y = np.meshgrid(x, y) R = np.sqrt(X**2 + Y**2) # Create wave pattern Z = np.sin(5 * R) / (R + 1e-6) # Plot and save 3D surface fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(X, Y, Z, cmap='viridis', edgecolor='none') ax.set_title('3D Wave Plot from Single Source') ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_zlabel('Amplitude') plt.tight_layout() plt.savefig(\"wave_3d_surface.png\", dpi=300) plt.show()","title":"4. Implementation in Python"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-observations-and-analysis","text":"Constructive Interference: Occurs where wave crests align, increasing amplitude. These appear as ridges or bright bands in the plot. Destructive Interference: Occurs where a crest meets a trough, canceling out. These are shown as flat (dark) regions. Symmetry: Due to the regular polygon setup and equal wave properties, the interference pattern is symmetrical, matching the geometry of the polygon. The complexity of the pattern increases with the number of sources, leading to denser interference zones.","title":"5. Observations and Analysis"},{"location":"1%20Physics/3%20Waves/Problem_1/#6-conclusion","text":"This simulation demonstrates the power of superposition in wave physics. By modeling water wave interference from a regular polygon arrangement, we observe both constructive and destructive interference in a visually striking and symmetric pattern. This exercise reinforces key wave principles and highlights the utility of simulation in physics education.","title":"6. Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Electromagnetism: Simulating the Effects of the Lorentz Force Problem 1: Lorentz Force Motivation The Lorentz force , given by: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}), \\] describes the force acting on a charged particle in electric ( \\( \\(\\vec{E}\\) \\) ) and magnetic ( \\( \\(\\vec{B}\\) \\) ) fields. This principle is foundational in particle accelerators, plasma confinement systems, and devices like mass spectrometers. Understanding and visualizing the trajectories resulting from this force helps in designing and interpreting physical systems where charged particles interact with electromagnetic fields. 1. Applications of the Lorentz Force Key Systems: Particle Accelerators \u2013 Use electric fields to accelerate and magnetic fields to steer particles. Mass Spectrometers \u2013 Use $$ \\vec{v} \\times \\vec{B} $$ to separate particles by mass-to-charge ratio. Plasma Confinement (e.g., Tokamaks) \u2013 Use strong magnetic fields to confine plasma. Relevance of Fields: Electric Fields ( ( \\(\\vec{E}\\) \\) ) : Accelerate particles. Magnetic Fields ( ( \\(\\vec{B}\\) \\) ) : Curve particle paths, confine motion. 2. Simulating Particle Motion Parameters: Charge: $$ q = 1 \\, \\text{C} $$ Mass: $$ m = 1 \\, \\text{g} = 0.001 \\, \\text{kg} $$ We solve the equations of motion: \\[ \\frac{d\\vec{v}}{dt} = \\frac{q}{m}(\\vec{E} + \\vec{v} \\times \\vec{B}), \\quad \\frac{d\\vec{r}}{dt} = \\vec{v} \\] Numerical Integration (RK4): import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # Charge (C) m = 0.001 # Mass (kg) c = 3e8 # Speed of light (m/s) dt = 1e-6 # Time step (s) steps = 100000 # Number of steps for a long trajectory # Fields E = np.array([0.0, 0.0, 1e3]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) # Initial conditions r = np.zeros((steps, 3)) # Position array v = np.zeros((steps, 3)) # Velocity array r[0] = np.array([0.0, 0.0, 0.0]) # Initial position v[0] = np.array([3e6, 0.0, 1e6]) # Initial velocity def acceleration(v): return (q / m) * (E + np.cross(v, B)) # RK4 integration for i in range(steps - 1): a1 = acceleration(v[i]) k1v = a1 * dt k1r = v[i] * dt a2 = acceleration(v[i] + 0.5 * k1v) k2v = a2 * dt k2r = (v[i] + 0.5 * k1v) * dt a3 = acceleration(v[i] + 0.5 * k2v) k3v = a3 * dt k3r = (v[i] + 0.5 * k2v) * dt a4 = acceleration(v[i] + k3v) k4v = a4 * dt k4r = (v[i] + k3v) * dt v[i + 1] = v[i] + (k1v + 2 * k2v + 2 * k3v + k4v) / 6 r[i + 1] = r[i] + (k1r + 2 * k2r + 2 * k3r + k4r) / 6 # Plot 3D trajectory (sample every 100 points for speed) fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[::100, 0], r[::100, 1], r[::100, 2], linewidth=1) ax.set_title(\"Very Long Charged Particle Trajectory (RK4)\") ax.set_xlabel(\"x [m]\") ax.set_ylabel(\"y [m]\") ax.set_zlabel(\"z [m]\") plt.tight_layout() plt.show() 3. Trajectory Scenarios A. Circular Motion (Uniform \\( \\(\\vec{B}\\) \\) , No \\( \\(\\vec{E}\\) \\) ) Initial condition : Velocity is perpendicular to the magnetic field. Expected trajectory : Circle in the plane perpendicular to \\( \\(\\vec{B}\\) \\) . Physical Background A charged particle in a uniform magnetic field experiences a centripetal force due to the Lorentz force: \\[ \\vec{F} = q\\vec{v} \\times \\vec{B} \\] If \\( \\(\\vec{v} \\perp \\vec{B}\\) \\) and there is no electric field, the particle moves in a circle with radius: \\[ r_L = \\frac{mv}{qB} \\] and angular frequency: \\[ \\omega_c = \\frac{qB}{m} \\] Python Simulation Code import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # Charge (C) m = 0.001 # Mass (kg) dt = 1e-6 # Time step (s) steps = 50000 # Number of steps B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) E = np.array([0.0, 0.0, 0.0]) # No electric field # Initial conditions r = np.zeros((steps, 3)) # Position array v = np.zeros((steps, 3)) # Velocity array # Start at origin, with velocity along y and B along z \u2192 orbit in x-y plane r[0] = np.array([1.0, 0.0, 0.0]) # Start off-center v[0] = np.array([0.0, 1e5, 0.0]) # Perpendicular to B for circular orbit def acceleration(v): return (q / m) * (E + np.cross(v, B)) # RK4 integration for i in range(steps - 1): a1 = acceleration(v[i]) k1v = a1 * dt k1r = v[i] * dt a2 = acceleration(v[i] + 0.5 * k1v) k2v = a2 * dt k2r = (v[i] + 0.5 * k1v) * dt a3 = acceleration(v[i] + 0.5 * k2v) k3v = a3 * dt k3r = (v[i] + 0.5 * k2v) * dt a4 = acceleration(v[i] + k3v) k4v = a4 * dt k4r = (v[i] + k3v) * dt v[i + 1] = v[i] + (k1v + 2 * k2v + 2 * k3v + k4v) / 6 r[i + 1] = r[i] + (k1r + 2 * k2r + 2 * k3r + k4r) / 6 # Plot 3D trajectory (it will be in x\u2013y plane with constant z) fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[::10, 0], r[::10, 1], r[::10, 2], linewidth=1.2) ax.set_title(\"Circular Orbit of a Charged Particle in 3D (RK4)\") ax.set_xlabel(\"x [m]\") ax.set_ylabel(\"y [m]\") ax.set_zlabel(\"z [m]\") ax.view_init(elev=30, azim=60) plt.tight_layout() plt.show() B. Spiral in Z-direction Initial condition : Add a vertical velocity component \\( \\(v_z\\) \\) to the initial velocity. Expected trajectory : Helical motion (spiral) around the magnetic field lines in the z-direction. Physical Background When a charged particle has a velocity component both perpendicular and parallel to a uniform magnetic field \\( \\(\\vec{B}\\) \\) , it follows a helical path. Circular motion in the plane perpendicular to \\( \\(\\vec{B}\\) \\) Constant drift along the direction of \\( \\(\\vec{B}\\) \\) This results in a spiral trajectory along the z-axis. Python Simulation Code import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # Charge (C) m = 0.001 # Mass (kg) dt = 1e-6 # Time step (s) steps = 50000 # Number of steps B = np.array([0.0, 0.0, 1.0]) # Magnetic field along z (T) E = np.array([1e3, 0.0, 0.0]) # Electric field along x (V/m) # Compute theoretical E x B drift velocity v_drift = np.cross(E, B) / np.dot(B, B) print(f\"Theoretical E x B drift velocity: {v_drift} m/s\") # Initial conditions r = np.zeros((steps, 3)) # Position array v = np.zeros((steps, 3)) # Velocity array # Start at origin with perpendicular velocity to B r[0] = np.array([0.0, 0.0, 0.0]) v[0] = np.array([0.0, 1e5, 0.0]) # Perpendicular to B, causes gyration def acceleration(v): return (q / m) * (E + np.cross(v, B)) # RK4 integration loop for i in range(steps - 1): a1 = acceleration(v[i]) k1v = a1 * dt k1r = v[i] * dt a2 = acceleration(v[i] + 0.5 * k1v) k2v = a2 * dt k2r = (v[i] + 0.5 * k1v) * dt a3 = acceleration(v[i] + 0.5 * k2v) k3v = a3 * dt k3r = (v[i] + 0.5 * k2v) * dt a4 = acceleration(v[i] + k3v) k4v = a4 * dt k4r = (v[i] + k3v) * dt v[i + 1] = v[i] + (k1v + 2 * k2v + 2 * k3v + k4v) / 6 r[i + 1] = r[i] + (k1r + 2 * k2r + 2 * k3r + k4r) / 6 # Plot 3D trajectory fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[::10, 0], r[::10, 1], r[::10, 2], linewidth=1.2, label='Trajectory') ax.set_title(\"Charged Particle Trajectory with E \u00d7 B Drift (RK4)\") ax.set_xlabel(\"x [m]\") ax.set_ylabel(\"y [m]\") ax.set_zlabel(\"z [m]\") ax.view_init(elev=30, azim=60) ax.legend() plt.tight_layout() plt.show() B. Spiral in Z-direction Initial condition : Add a vertical velocity component \\( \\(v_z\\) \\) to the initial velocity. Expected trajectory : Helical motion (spiral) around the magnetic field lines in the z-direction. Physical Background When a charged particle has a velocity component both perpendicular and parallel to a uniform magnetic field \\( \\(\\vec{B}\\) \\) , it follows a helical path. Circular motion in the plane perpendicular to \\( \\(\\vec{B}\\) \\) Constant drift along the direction of \\( \\(\\vec{B}\\) \\) This results in a spiral trajectory along the z-axis. Python Simulation Code import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # Charge (C) m = 0.001 # Mass (kg) dt = 1e-5 # Smaller time step for stability T = 0.1 # Shorter total time to keep computation reasonable N = int(T / dt) # Fields B = np.array([0, 0, 1.0]) # Magnetic field (T) E = np.array([0, 0, 0]) # No electric field # Initial conditions: circular motion + axial drift v0 = np.array([1.0, 0.0, 0.5]) # x-y circular, z linear r0 = np.array([0.0, 0.0, 0.0]) # Initialize arrays r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0] = r0 v[0] = v0 # Lorentz force acceleration def acceleration(v): return (q / m) * (E + np.cross(v, B)) # RK4 integration for i in range(N - 1): a1 = acceleration(v[i]) k1v = a1 * dt k1r = v[i] * dt a2 = acceleration(v[i] + 0.5 * k1v) k2v = a2 * dt k2r = (v[i] + 0.5 * k1v) * dt a3 = acceleration(v[i] + 0.5 * k2v) k3v = a3 * dt k3r = (v[i] + 0.5 * k2v) * dt a4 = acceleration(v[i] + k3v) k4v = a4 * dt k4r = (v[i] + k3v) * dt v[i + 1] = v[i] + (k1v + 2*k2v + 2*k3v + k4v) / 6 r[i + 1] = r[i] + (k1r + 2*k2r + 2*k3r + k4r) / 6 # Plot the helical trajectory fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2], linewidth=1) ax.set_title(\"Stable 3D Spiral Trajectory Along z-axis (RK4)\") ax.set_xlabel(\"x [m]\") ax.set_ylabel(\"y [m]\") ax.set_zlabel(\"z [m]\") ax.view_init(elev=30, azim=60) plt.tight_layout() plt.show() C. Crossed Fields \u2013 Drift Motion Field configuration : Apply crossed electric and magnetic fields: $$ \\vec{E} = [1, 0, 0], \\quad \\vec{B} = [0, 0, 1] $$ Expected result : The particle experiences a drift due to the cross product: $$ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} $$ This drift is perpendicular to both the electric and magnetic fields, causing the charged particle to move with a constant velocity in the \\( \\(y\\) \\) -direction while spiraling due to the magnetic field. 4. Parameter Exploration Parameters to Vary: Electric field \\( \\(\\vec{E}\\) \\) and magnetic field \\( \\(\\vec{B}\\) \\) strengths and directions Initial velocity vector \\( \\(\\vec{v}_0\\) \\) Charge-to-mass ratio \\( \\(\\frac{q}{m}\\) \\) Key Quantities to Observe: Larmor radius (radius of circular motion): $$ r_L = \\frac{mv_\\perp}{qB} $$ Cyclotron frequency (angular frequency of rotation): $$ \\omega_c = \\frac{qB}{m} $$ Drift velocity in crossed electric and magnetic fields: $$ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} $$ Use these analytical relationships to: Predict the trajectory before simulating. Compare numerical results to theoretical expectations. Validate your code's physical accuracy. 5. Real-World Relevance System Role of Lorentz Force Cyclotron Charged particles move in circular paths under \\( \\(\\vec{B}\\) \\) . Mass Spectrometer Particle curvature \\( \\(\\propto \\frac{m}{q}\\) \\) helps identify isotopes. Magnetic Bottle Magnetic mirror effect traps particles via field gradients. Solar Wind Charged solar particles are deflected by Earth's magnetosphere. These systems depend critically on the Lorentz force to manipulate, trap, or sort charged particles. 6. Extension Ideas To make the simulation more advanced and realistic, consider exploring: Non-uniform magnetic fields (e.g., magnetic mirrors, Earth's dipole field, magnetic bottles) Time-varying electric fields (as seen in radio-frequency (RF) ion traps and linear accelerators) Multiple interacting particles (introduce Coulomb forces to simulate plasma dynamics) Relativistic effects (for particles approaching the speed of light, modify Newtonian dynamics) Focusing and guiding mechanisms in accelerators (e.g., quadrupole magnets, beam optics) These features reflect real-world complexities and provide stepping stones toward simulating full plasma systems, particle accelerators, and astrophysical plasmas.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#electromagnetism-simulating-the-effects-of-the-lorentz-force","text":"","title":"Electromagnetism: Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1-lorentz-force","text":"","title":"Problem 1: Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force , given by: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}), \\] describes the force acting on a charged particle in electric ( \\( \\(\\vec{E}\\) \\) ) and magnetic ( \\( \\(\\vec{B}\\) \\) ) fields. This principle is foundational in particle accelerators, plasma confinement systems, and devices like mass spectrometers. Understanding and visualizing the trajectories resulting from this force helps in designing and interpreting physical systems where charged particles interact with electromagnetic fields.","title":"Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-applications-of-the-lorentz-force","text":"","title":"1. Applications of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#key-systems","text":"Particle Accelerators \u2013 Use electric fields to accelerate and magnetic fields to steer particles. Mass Spectrometers \u2013 Use $$ \\vec{v} \\times \\vec{B} $$ to separate particles by mass-to-charge ratio. Plasma Confinement (e.g., Tokamaks) \u2013 Use strong magnetic fields to confine plasma.","title":"Key Systems:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#relevance-of-fields","text":"Electric Fields ( ( \\(\\vec{E}\\) \\) ) : Accelerate particles. Magnetic Fields ( ( \\(\\vec{B}\\) \\) ) : Curve particle paths, confine motion.","title":"Relevance of Fields:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-simulating-particle-motion","text":"","title":"2. Simulating Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameters","text":"Charge: $$ q = 1 \\, \\text{C} $$ Mass: $$ m = 1 \\, \\text{g} = 0.001 \\, \\text{kg} $$ We solve the equations of motion: \\[ \\frac{d\\vec{v}}{dt} = \\frac{q}{m}(\\vec{E} + \\vec{v} \\times \\vec{B}), \\quad \\frac{d\\vec{r}}{dt} = \\vec{v} \\]","title":"Parameters:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#numerical-integration-rk4","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # Charge (C) m = 0.001 # Mass (kg) c = 3e8 # Speed of light (m/s) dt = 1e-6 # Time step (s) steps = 100000 # Number of steps for a long trajectory # Fields E = np.array([0.0, 0.0, 1e3]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) # Initial conditions r = np.zeros((steps, 3)) # Position array v = np.zeros((steps, 3)) # Velocity array r[0] = np.array([0.0, 0.0, 0.0]) # Initial position v[0] = np.array([3e6, 0.0, 1e6]) # Initial velocity def acceleration(v): return (q / m) * (E + np.cross(v, B)) # RK4 integration for i in range(steps - 1): a1 = acceleration(v[i]) k1v = a1 * dt k1r = v[i] * dt a2 = acceleration(v[i] + 0.5 * k1v) k2v = a2 * dt k2r = (v[i] + 0.5 * k1v) * dt a3 = acceleration(v[i] + 0.5 * k2v) k3v = a3 * dt k3r = (v[i] + 0.5 * k2v) * dt a4 = acceleration(v[i] + k3v) k4v = a4 * dt k4r = (v[i] + k3v) * dt v[i + 1] = v[i] + (k1v + 2 * k2v + 2 * k3v + k4v) / 6 r[i + 1] = r[i] + (k1r + 2 * k2r + 2 * k3r + k4r) / 6 # Plot 3D trajectory (sample every 100 points for speed) fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[::100, 0], r[::100, 1], r[::100, 2], linewidth=1) ax.set_title(\"Very Long Charged Particle Trajectory (RK4)\") ax.set_xlabel(\"x [m]\") ax.set_ylabel(\"y [m]\") ax.set_zlabel(\"z [m]\") plt.tight_layout() plt.show()","title":"Numerical Integration (RK4):"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-trajectory-scenarios","text":"","title":"3. Trajectory Scenarios"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#a-circular-motion-uniform-vecb-no-vece","text":"Initial condition : Velocity is perpendicular to the magnetic field. Expected trajectory : Circle in the plane perpendicular to \\( \\(\\vec{B}\\) \\) .","title":"A. Circular Motion (Uniform \\(\\(\\vec{B}\\)\\), No \\(\\(\\vec{E}\\)\\))"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#physical-background","text":"A charged particle in a uniform magnetic field experiences a centripetal force due to the Lorentz force: \\[ \\vec{F} = q\\vec{v} \\times \\vec{B} \\] If \\( \\(\\vec{v} \\perp \\vec{B}\\) \\) and there is no electric field, the particle moves in a circle with radius: \\[ r_L = \\frac{mv}{qB} \\] and angular frequency: \\[ \\omega_c = \\frac{qB}{m} \\]","title":"Physical Background"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-simulation-code","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # Charge (C) m = 0.001 # Mass (kg) dt = 1e-6 # Time step (s) steps = 50000 # Number of steps B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) E = np.array([0.0, 0.0, 0.0]) # No electric field # Initial conditions r = np.zeros((steps, 3)) # Position array v = np.zeros((steps, 3)) # Velocity array # Start at origin, with velocity along y and B along z \u2192 orbit in x-y plane r[0] = np.array([1.0, 0.0, 0.0]) # Start off-center v[0] = np.array([0.0, 1e5, 0.0]) # Perpendicular to B for circular orbit def acceleration(v): return (q / m) * (E + np.cross(v, B)) # RK4 integration for i in range(steps - 1): a1 = acceleration(v[i]) k1v = a1 * dt k1r = v[i] * dt a2 = acceleration(v[i] + 0.5 * k1v) k2v = a2 * dt k2r = (v[i] + 0.5 * k1v) * dt a3 = acceleration(v[i] + 0.5 * k2v) k3v = a3 * dt k3r = (v[i] + 0.5 * k2v) * dt a4 = acceleration(v[i] + k3v) k4v = a4 * dt k4r = (v[i] + k3v) * dt v[i + 1] = v[i] + (k1v + 2 * k2v + 2 * k3v + k4v) / 6 r[i + 1] = r[i] + (k1r + 2 * k2r + 2 * k3r + k4r) / 6 # Plot 3D trajectory (it will be in x\u2013y plane with constant z) fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[::10, 0], r[::10, 1], r[::10, 2], linewidth=1.2) ax.set_title(\"Circular Orbit of a Charged Particle in 3D (RK4)\") ax.set_xlabel(\"x [m]\") ax.set_ylabel(\"y [m]\") ax.set_zlabel(\"z [m]\") ax.view_init(elev=30, azim=60) plt.tight_layout() plt.show()","title":"Python Simulation Code"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#b-spiral-in-z-direction","text":"Initial condition : Add a vertical velocity component \\( \\(v_z\\) \\) to the initial velocity. Expected trajectory : Helical motion (spiral) around the magnetic field lines in the z-direction.","title":"B. Spiral in Z-direction"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#physical-background_1","text":"When a charged particle has a velocity component both perpendicular and parallel to a uniform magnetic field \\( \\(\\vec{B}\\) \\) , it follows a helical path. Circular motion in the plane perpendicular to \\( \\(\\vec{B}\\) \\) Constant drift along the direction of \\( \\(\\vec{B}\\) \\) This results in a spiral trajectory along the z-axis.","title":"Physical Background"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-simulation-code_1","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # Charge (C) m = 0.001 # Mass (kg) dt = 1e-6 # Time step (s) steps = 50000 # Number of steps B = np.array([0.0, 0.0, 1.0]) # Magnetic field along z (T) E = np.array([1e3, 0.0, 0.0]) # Electric field along x (V/m) # Compute theoretical E x B drift velocity v_drift = np.cross(E, B) / np.dot(B, B) print(f\"Theoretical E x B drift velocity: {v_drift} m/s\") # Initial conditions r = np.zeros((steps, 3)) # Position array v = np.zeros((steps, 3)) # Velocity array # Start at origin with perpendicular velocity to B r[0] = np.array([0.0, 0.0, 0.0]) v[0] = np.array([0.0, 1e5, 0.0]) # Perpendicular to B, causes gyration def acceleration(v): return (q / m) * (E + np.cross(v, B)) # RK4 integration loop for i in range(steps - 1): a1 = acceleration(v[i]) k1v = a1 * dt k1r = v[i] * dt a2 = acceleration(v[i] + 0.5 * k1v) k2v = a2 * dt k2r = (v[i] + 0.5 * k1v) * dt a3 = acceleration(v[i] + 0.5 * k2v) k3v = a3 * dt k3r = (v[i] + 0.5 * k2v) * dt a4 = acceleration(v[i] + k3v) k4v = a4 * dt k4r = (v[i] + k3v) * dt v[i + 1] = v[i] + (k1v + 2 * k2v + 2 * k3v + k4v) / 6 r[i + 1] = r[i] + (k1r + 2 * k2r + 2 * k3r + k4r) / 6 # Plot 3D trajectory fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[::10, 0], r[::10, 1], r[::10, 2], linewidth=1.2, label='Trajectory') ax.set_title(\"Charged Particle Trajectory with E \u00d7 B Drift (RK4)\") ax.set_xlabel(\"x [m]\") ax.set_ylabel(\"y [m]\") ax.set_zlabel(\"z [m]\") ax.view_init(elev=30, azim=60) ax.legend() plt.tight_layout() plt.show()","title":"Python Simulation Code"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#b-spiral-in-z-direction_1","text":"Initial condition : Add a vertical velocity component \\( \\(v_z\\) \\) to the initial velocity. Expected trajectory : Helical motion (spiral) around the magnetic field lines in the z-direction.","title":"B. Spiral in Z-direction"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#physical-background_2","text":"When a charged particle has a velocity component both perpendicular and parallel to a uniform magnetic field \\( \\(\\vec{B}\\) \\) , it follows a helical path. Circular motion in the plane perpendicular to \\( \\(\\vec{B}\\) \\) Constant drift along the direction of \\( \\(\\vec{B}\\) \\) This results in a spiral trajectory along the z-axis.","title":"Physical Background"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-simulation-code_2","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # Charge (C) m = 0.001 # Mass (kg) dt = 1e-5 # Smaller time step for stability T = 0.1 # Shorter total time to keep computation reasonable N = int(T / dt) # Fields B = np.array([0, 0, 1.0]) # Magnetic field (T) E = np.array([0, 0, 0]) # No electric field # Initial conditions: circular motion + axial drift v0 = np.array([1.0, 0.0, 0.5]) # x-y circular, z linear r0 = np.array([0.0, 0.0, 0.0]) # Initialize arrays r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0] = r0 v[0] = v0 # Lorentz force acceleration def acceleration(v): return (q / m) * (E + np.cross(v, B)) # RK4 integration for i in range(N - 1): a1 = acceleration(v[i]) k1v = a1 * dt k1r = v[i] * dt a2 = acceleration(v[i] + 0.5 * k1v) k2v = a2 * dt k2r = (v[i] + 0.5 * k1v) * dt a3 = acceleration(v[i] + 0.5 * k2v) k3v = a3 * dt k3r = (v[i] + 0.5 * k2v) * dt a4 = acceleration(v[i] + k3v) k4v = a4 * dt k4r = (v[i] + k3v) * dt v[i + 1] = v[i] + (k1v + 2*k2v + 2*k3v + k4v) / 6 r[i + 1] = r[i] + (k1r + 2*k2r + 2*k3r + k4r) / 6 # Plot the helical trajectory fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2], linewidth=1) ax.set_title(\"Stable 3D Spiral Trajectory Along z-axis (RK4)\") ax.set_xlabel(\"x [m]\") ax.set_ylabel(\"y [m]\") ax.set_zlabel(\"z [m]\") ax.view_init(elev=30, azim=60) plt.tight_layout() plt.show()","title":"Python Simulation Code"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#c-crossed-fields-drift-motion","text":"Field configuration : Apply crossed electric and magnetic fields: $$ \\vec{E} = [1, 0, 0], \\quad \\vec{B} = [0, 0, 1] $$ Expected result : The particle experiences a drift due to the cross product: $$ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} $$ This drift is perpendicular to both the electric and magnetic fields, causing the charged particle to move with a constant velocity in the \\( \\(y\\) \\) -direction while spiraling due to the magnetic field.","title":"C. Crossed Fields \u2013 Drift Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-parameter-exploration","text":"","title":"4. Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameters-to-vary","text":"Electric field \\( \\(\\vec{E}\\) \\) and magnetic field \\( \\(\\vec{B}\\) \\) strengths and directions Initial velocity vector \\( \\(\\vec{v}_0\\) \\) Charge-to-mass ratio \\( \\(\\frac{q}{m}\\) \\)","title":"Parameters to Vary:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#key-quantities-to-observe","text":"Larmor radius (radius of circular motion): $$ r_L = \\frac{mv_\\perp}{qB} $$ Cyclotron frequency (angular frequency of rotation): $$ \\omega_c = \\frac{qB}{m} $$ Drift velocity in crossed electric and magnetic fields: $$ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} $$ Use these analytical relationships to: Predict the trajectory before simulating. Compare numerical results to theoretical expectations. Validate your code's physical accuracy.","title":"Key Quantities to Observe:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-real-world-relevance","text":"System Role of Lorentz Force Cyclotron Charged particles move in circular paths under \\( \\(\\vec{B}\\) \\) . Mass Spectrometer Particle curvature \\( \\(\\propto \\frac{m}{q}\\) \\) helps identify isotopes. Magnetic Bottle Magnetic mirror effect traps particles via field gradients. Solar Wind Charged solar particles are deflected by Earth's magnetosphere. These systems depend critically on the Lorentz force to manipulate, trap, or sort charged particles.","title":"5. Real-World Relevance"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#6-extension-ideas","text":"To make the simulation more advanced and realistic, consider exploring: Non-uniform magnetic fields (e.g., magnetic mirrors, Earth's dipole field, magnetic bottles) Time-varying electric fields (as seen in radio-frequency (RF) ion traps and linear accelerators) Multiple interacting particles (introduce Coulomb forces to simulate plasma dynamics) Relativistic effects (for particles approaching the speed of light, modify Newtonian dynamics) Focusing and guiding mechanisms in accelerators (e.g., quadrupole magnets, beam optics) These features reflect real-world complexities and provide stepping stones toward simulating full plasma systems, particle accelerators, and astrophysical plasmas.","title":"6. Extension Ideas"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Equivalent Resistance Using Graph Theory Motivation The equivalent resistance between two terminals (START and END) in an electrical network is a central concept in circuit analysis. While basic configurations can be handled with simple series and parallel rules, complex circuits with many junctions and loops require a more robust approach. Using graph theory , we model the circuit as a graph where: - Nodes represent junctions, - Edges represent resistors, - Weights on edges represent resistance values. This transforms circuit simplification into a graph-reduction problem. The process can be fully automated and is essential for tasks like circuit simulation, network optimization, and computer-aided design. 1. Graph-Based Circuit Simplification Step-by-Step Approach Given a weighted undirected graph: START and END are the terminals. Each edge \\(e_{ij}\\) has a resistance \\(R_{ij}\\) . The goal is to compute a single equivalent resistance \\(R_{\\text{eq}}\\) between START and END. We apply the following reduction rules iteratively: 1.1 Series Reduction If a node (not START or END) has exactly two neighbors and connects only to them, its resistors are in series . Replace this subgraph: A -- R\u2081 -- B -- R\u2082 -- C with: A -- R\u2081\u2082 -- C Where: \\[ R_{\\text{eq}} = R_1 + R_2 \\] 1.2 Parallel Reduction If multiple resistors connect the same two nodes, they are in parallel . Replace this: A -- R\u2081 -- B A -- R\u2082 -- B with: A -- R_{\\text{eq}} -- B Where: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} \\] 1.3 Iteration Repeat series and parallel simplification until only one resistor remains between START and END: \\[ R_{\\text{total}} = R_{\\text{eq}} \\] 2. Python Algorithm Step 1: Original Circuit (with parallel and series resistors) !pip install schemdraw import schemdraw import schemdraw.elements as elm # Step 1: Original Circuit with schemdraw.Drawing() as d: d.config(unit=2.5) d += elm.SourceV().up().label('V', loc='top') d += elm.Line().right() d += elm.Resistor().label('5\u03a9').right() d += elm.Dot() d.push() d += elm.Line().down() d += elm.Resistor().label('10\u03a9') d += elm.Line().up() d.pop() d += elm.Line().up() d += elm.Resistor().label('30\u03a9') d += elm.Line().down() d += elm.Dot() d += elm.Resistor().label('5\u03a9').right() d += elm.Resistor().label('5\u03a9').right() d += elm.Ground() Step 2: After Parallel Reduction import schemdraw import schemdraw.elements as elm # Step 2: Parallel Resistors Replaced with Equivalent with schemdraw.Drawing() as d: d.config(unit=2.5) d += elm.SourceV().up().label('V', loc='top') d += elm.Line().right() d += elm.Resistor().label('5\u03a9').right() d += elm.Resistor().label('7.5\u03a9').right().label('(10\u03a9 || 30\u03a9)', loc='bottom') d += elm.Resistor().label('5\u03a9').right() d += elm.Resistor().label('5\u03a9').right() d += elm.Ground() Step 3: Final Equivalent Resistance Only import schemdraw import schemdraw.elements as elm # Step 3: Fully Reduced to One Equivalent Resistor with schemdraw.Drawing() as d: d.config(unit=2.5) d += elm.SourceV().up().label('V', loc='top') d += elm.Line().right() d += elm.Resistor().label('22.5\u03a9').right().label('(5+7.5+5+5)', loc='bottom') d += elm.Ground() 3. Example Analysis Given the test circuit: START \u2192 A: \\(R = 2\\,\\Omega\\) A \u2192 B: \\(R = 3\\,\\Omega\\) B \u2192 END: \\(R = 4\\,\\Omega\\) A \u2192 END: \\(R = 6\\,\\Omega\\) Step-by-step: Combine A\u2013B and B\u2013END (series): \\(R_{\\text{AB-END}} = 3 + 4 = 7\\,\\Omega\\) A has two paths to END: One path is: \\(7\\,\\Omega\\) Other path is: \\(6\\,\\Omega\\) Combine those in parallel: $$ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{6} + \\frac{1}{7} = \\frac{13}{42} \\Rightarrow R_{\\text{eq}} \\approx 3.23\\,\\Omega $$ Finally, add START\u2013A: $$ R_{\\text{total}} = 2 + 3.23 = 5.23\\,\\Omega $$ 4. Conclusion We showed how to: Use graph theory to model electrical circuits. Detect and simplify series and parallel connections. Automate the process using Python and networkx . This method scales well to arbitrarily complex networks and is highly applicable to modern engineering workflows such as simulation, layout, and optimization of electrical systems.","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#motivation","text":"The equivalent resistance between two terminals (START and END) in an electrical network is a central concept in circuit analysis. While basic configurations can be handled with simple series and parallel rules, complex circuits with many junctions and loops require a more robust approach. Using graph theory , we model the circuit as a graph where: - Nodes represent junctions, - Edges represent resistors, - Weights on edges represent resistance values. This transforms circuit simplification into a graph-reduction problem. The process can be fully automated and is essential for tasks like circuit simulation, network optimization, and computer-aided design.","title":"Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-graph-based-circuit-simplification","text":"","title":"1. Graph-Based Circuit Simplification"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-by-step-approach","text":"Given a weighted undirected graph: START and END are the terminals. Each edge \\(e_{ij}\\) has a resistance \\(R_{ij}\\) . The goal is to compute a single equivalent resistance \\(R_{\\text{eq}}\\) between START and END. We apply the following reduction rules iteratively:","title":"Step-by-Step Approach"},{"location":"1%20Physics/5%20Circuits/Problem_1/#11-series-reduction","text":"If a node (not START or END) has exactly two neighbors and connects only to them, its resistors are in series . Replace this subgraph: A -- R\u2081 -- B -- R\u2082 -- C with: A -- R\u2081\u2082 -- C Where: \\[ R_{\\text{eq}} = R_1 + R_2 \\]","title":"1.1 Series Reduction"},{"location":"1%20Physics/5%20Circuits/Problem_1/#12-parallel-reduction","text":"If multiple resistors connect the same two nodes, they are in parallel . Replace this: A -- R\u2081 -- B A -- R\u2082 -- B with: A -- R_{\\text{eq}} -- B Where: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} \\]","title":"1.2 Parallel Reduction"},{"location":"1%20Physics/5%20Circuits/Problem_1/#13-iteration","text":"Repeat series and parallel simplification until only one resistor remains between START and END: \\[ R_{\\text{total}} = R_{\\text{eq}} \\]","title":"1.3 Iteration"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-python-algorithm","text":"","title":"2. Python Algorithm"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-1-original-circuit-with-parallel-and-series-resistors","text":"!pip install schemdraw import schemdraw import schemdraw.elements as elm # Step 1: Original Circuit with schemdraw.Drawing() as d: d.config(unit=2.5) d += elm.SourceV().up().label('V', loc='top') d += elm.Line().right() d += elm.Resistor().label('5\u03a9').right() d += elm.Dot() d.push() d += elm.Line().down() d += elm.Resistor().label('10\u03a9') d += elm.Line().up() d.pop() d += elm.Line().up() d += elm.Resistor().label('30\u03a9') d += elm.Line().down() d += elm.Dot() d += elm.Resistor().label('5\u03a9').right() d += elm.Resistor().label('5\u03a9').right() d += elm.Ground()","title":"Step 1: Original Circuit (with parallel and series resistors)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-2-after-parallel-reduction","text":"import schemdraw import schemdraw.elements as elm # Step 2: Parallel Resistors Replaced with Equivalent with schemdraw.Drawing() as d: d.config(unit=2.5) d += elm.SourceV().up().label('V', loc='top') d += elm.Line().right() d += elm.Resistor().label('5\u03a9').right() d += elm.Resistor().label('7.5\u03a9').right().label('(10\u03a9 || 30\u03a9)', loc='bottom') d += elm.Resistor().label('5\u03a9').right() d += elm.Resistor().label('5\u03a9').right() d += elm.Ground()","title":"Step 2: After Parallel Reduction"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-3-final-equivalent-resistance-only","text":"import schemdraw import schemdraw.elements as elm # Step 3: Fully Reduced to One Equivalent Resistor with schemdraw.Drawing() as d: d.config(unit=2.5) d += elm.SourceV().up().label('V', loc='top') d += elm.Line().right() d += elm.Resistor().label('22.5\u03a9').right().label('(5+7.5+5+5)', loc='bottom') d += elm.Ground()","title":"Step 3: Final Equivalent Resistance Only"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-example-analysis","text":"Given the test circuit: START \u2192 A: \\(R = 2\\,\\Omega\\) A \u2192 B: \\(R = 3\\,\\Omega\\) B \u2192 END: \\(R = 4\\,\\Omega\\) A \u2192 END: \\(R = 6\\,\\Omega\\)","title":"3. Example Analysis"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-by-step","text":"Combine A\u2013B and B\u2013END (series): \\(R_{\\text{AB-END}} = 3 + 4 = 7\\,\\Omega\\) A has two paths to END: One path is: \\(7\\,\\Omega\\) Other path is: \\(6\\,\\Omega\\) Combine those in parallel: $$ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{6} + \\frac{1}{7} = \\frac{13}{42} \\Rightarrow R_{\\text{eq}} \\approx 3.23\\,\\Omega $$ Finally, add START\u2013A: $$ R_{\\text{total}} = 2 + 3.23 = 5.23\\,\\Omega $$","title":"Step-by-step:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#4-conclusion","text":"We showed how to: Use graph theory to model electrical circuits. Detect and simplify series and parallel connections. Automate the process using Python and networkx . This method scales well to arbitrarily complex networks and is highly applicable to modern engineering workflows such as simulation, layout, and optimization of electrical systems.","title":"4. Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 Exploring the Central Limit Theorem through Simulations Motivation The Central Limit Theorem (CLT) is a foundational principle in statistics. It asserts that the distribution of sample means approaches a normal distribution as the sample size increases, regardless of the original distribution's shape. This property has profound implications in statistics and real-world applications. Through simulation, we can vividly observe the CLT in action, enhancing both understanding and intuition. 1. Simulating Sampling Distributions To explore the CLT, we simulate sampling distributions using the following population distributions: Uniform Distribution: A distribution where every value within a specified range is equally likely. Its probability density function (PDF) is constant within the interval. Exponential Distribution: A continuous probability distribution commonly used to model time between events in a Poisson process. It is defined by the formula: $$ f(x; \\lambda) = \\lambda e^{-\\lambda x}, \\quad x \\geq 0 $$ - Binomial Distribution: A discrete distribution that represents the number of successes in a fixed number of independent Bernoulli trials with the same probability of success: \\[ P(X = k) = \\binom{n}{k} p^k (1 - p)^{n - k} \\] Uniform(0, 1) - flat, no skew Exponential(\u03bb=1) \u2013 heavily right-skewed Binomial(n=10, p=0.5) \u2013 discrete, symmetric We generate a large synthetic population (e.g., 100,000 samples) for each distribution: 2. Sampling and Visualization Sample Mean The sample mean is the average of a sample: The sample mean is defined as: \\[ \\bar{x} = \\frac{1}{n} \\sum_{i=1}^{n} x_i \\] Sampling Distribution The sampling distribution of the sample mean is the probability distribution of all possible means from samples of a given size from the population. import numpy as np import matplotlib.pyplot as plt import seaborn as sns from scipy.stats import norm # Set the random seed for reproducibility np.random.seed(0) # ---------------------------- # 1. Generate Populations # ---------------------------- # Uniform Distribution: U(0, 1) pop_uniform = np.random.uniform(0, 1, 100000) # Exponential Distribution: \u03bb = 1 pop_exponential = np.random.exponential(scale=1.0, size=100000) # Binomial Distribution: n = 10, p = 0.5 pop_binomial = np.random.binomial(n=10, p=0.5, size=100000) # ---------------------------- # 2. Sampling and Visualization Function # ---------------------------- def plot_sampling_distribution(population, sample_sizes, dist_name): \"\"\" Plots the sampling distribution of the mean for various sample sizes. \"\"\" for n in sample_sizes: # Generate 10,000 sample means sample_means = [np.mean(np.random.choice(population, size=n, replace=False)) for _ in range(10000)] # Plot histogram sns.histplot(sample_means, kde=True, stat=\"density\", bins=30, color=\"skyblue\", label=f\"Sample size = {n}\") # Overlay normal curve mu, sigma = np.mean(sample_means), np.std(sample_means) x = np.linspace(min(sample_means), max(sample_means), 100) plt.plot(x, norm.pdf(x, mu, sigma), 'r--', label=\"Normal PDF\") # Labels and title plt.title(f\"Sampling Distribution of the Mean\\n{dist_name} Distribution (n = {n})\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Density\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() # ---------------------------- # 3. Run Simulations # ---------------------------- sample_sizes = [5, 10, 30, 50] plot_sampling_distribution(pop_uniform, sample_sizes, \"Uniform\") plot_sampling_distribution(pop_exponential, sample_sizes, \"Exponential\") plot_sampling_distribution(pop_binomial, sample_sizes, \"Binomial\") Run the plots for different sample sizes. As the sample size increases, the sampling distribution becomes more bell-shaped and symmetric, illustrating convergence to normality. 3. Parameter Exploration We examine how: The shape of the original distribution affects the speed of convergence. The sample size influences the accuracy and spread of the sample mean. The variance of the population affects the spread of the sampling distribution. Variance The variance of the population ( \\(\\sigma^2\\) ) measures the dispersion from the mean. The variance of the sampling distribution of the mean is: \\[ \\text{Var}(\\bar{x}) = \\frac{\\sigma^2}{n} \\] Expectations The more skewed the original distribution, the larger the sample size needed for convergence. Uniform distributions converge more rapidly than exponential ones. 4. Practical Applications Understanding the CLT is essential in fields such as: Statistics: Confidence intervals and hypothesis testing rely on CLT. Manufacturing: Used in quality control to assess process stability. Finance: CLT helps model and assess risk using aggregated returns. Medical Trials: Helps ensure reliability of results from sampled patient data. Deliverables A Python script or notebook with simulations using NumPy, Matplotlib, and Seaborn. Plots illustrating sampling distributions from different population types. Mathematical definitions embedded next to each plot and concept. A Markdown discussion relating simulation results to theoretical expectations. Code Hints Use numpy.random to generate populations and samples. Plot with seaborn.histplot() and overlay a normal curve using scipy.stats.norm.pdf. Use np.random.seed() for reproducibility. Conclusion The Central Limit Theorem, though abstract in theory, becomes intuitive through computational experiments. Simulations show that regardless of the population\u2019s distribution, the mean of sufficiently large samples tends to be normally distributed. This underpins much of statistical inference, from confidence intervals to decision-making models. Each plot is supported by mathematical definitions to reinforce learning and interpretation.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exploring-the-central-limit-theorem-through-simulations","text":"","title":"Exploring the Central Limit Theorem through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) is a foundational principle in statistics. It asserts that the distribution of sample means approaches a normal distribution as the sample size increases, regardless of the original distribution's shape. This property has profound implications in statistics and real-world applications. Through simulation, we can vividly observe the CLT in action, enhancing both understanding and intuition.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-simulating-sampling-distributions","text":"To explore the CLT, we simulate sampling distributions using the following population distributions: Uniform Distribution: A distribution where every value within a specified range is equally likely. Its probability density function (PDF) is constant within the interval. Exponential Distribution: A continuous probability distribution commonly used to model time between events in a Poisson process. It is defined by the formula: $$ f(x; \\lambda) = \\lambda e^{-\\lambda x}, \\quad x \\geq 0 $$ - Binomial Distribution: A discrete distribution that represents the number of successes in a fixed number of independent Bernoulli trials with the same probability of success: \\[ P(X = k) = \\binom{n}{k} p^k (1 - p)^{n - k} \\] Uniform(0, 1) - flat, no skew Exponential(\u03bb=1) \u2013 heavily right-skewed Binomial(n=10, p=0.5) \u2013 discrete, symmetric We generate a large synthetic population (e.g., 100,000 samples) for each distribution:","title":"1. Simulating Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-sampling-and-visualization","text":"","title":"2. Sampling and Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#sample-mean","text":"The sample mean is the average of a sample: The sample mean is defined as: \\[ \\bar{x} = \\frac{1}{n} \\sum_{i=1}^{n} x_i \\]","title":"Sample Mean"},{"location":"1%20Physics/6%20Statistics/Problem_1/#sampling-distribution","text":"The sampling distribution of the sample mean is the probability distribution of all possible means from samples of a given size from the population. import numpy as np import matplotlib.pyplot as plt import seaborn as sns from scipy.stats import norm # Set the random seed for reproducibility np.random.seed(0) # ---------------------------- # 1. Generate Populations # ---------------------------- # Uniform Distribution: U(0, 1) pop_uniform = np.random.uniform(0, 1, 100000) # Exponential Distribution: \u03bb = 1 pop_exponential = np.random.exponential(scale=1.0, size=100000) # Binomial Distribution: n = 10, p = 0.5 pop_binomial = np.random.binomial(n=10, p=0.5, size=100000) # ---------------------------- # 2. Sampling and Visualization Function # ---------------------------- def plot_sampling_distribution(population, sample_sizes, dist_name): \"\"\" Plots the sampling distribution of the mean for various sample sizes. \"\"\" for n in sample_sizes: # Generate 10,000 sample means sample_means = [np.mean(np.random.choice(population, size=n, replace=False)) for _ in range(10000)] # Plot histogram sns.histplot(sample_means, kde=True, stat=\"density\", bins=30, color=\"skyblue\", label=f\"Sample size = {n}\") # Overlay normal curve mu, sigma = np.mean(sample_means), np.std(sample_means) x = np.linspace(min(sample_means), max(sample_means), 100) plt.plot(x, norm.pdf(x, mu, sigma), 'r--', label=\"Normal PDF\") # Labels and title plt.title(f\"Sampling Distribution of the Mean\\n{dist_name} Distribution (n = {n})\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Density\") plt.legend() plt.grid(True) plt.tight_layout() plt.show() # ---------------------------- # 3. Run Simulations # ---------------------------- sample_sizes = [5, 10, 30, 50] plot_sampling_distribution(pop_uniform, sample_sizes, \"Uniform\") plot_sampling_distribution(pop_exponential, sample_sizes, \"Exponential\") plot_sampling_distribution(pop_binomial, sample_sizes, \"Binomial\") Run the plots for different sample sizes. As the sample size increases, the sampling distribution becomes more bell-shaped and symmetric, illustrating convergence to normality.","title":"Sampling Distribution"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-parameter-exploration","text":"We examine how: The shape of the original distribution affects the speed of convergence. The sample size influences the accuracy and spread of the sample mean. The variance of the population affects the spread of the sampling distribution.","title":"3. Parameter Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#variance","text":"The variance of the population ( \\(\\sigma^2\\) ) measures the dispersion from the mean. The variance of the sampling distribution of the mean is: \\[ \\text{Var}(\\bar{x}) = \\frac{\\sigma^2}{n} \\]","title":"Variance"},{"location":"1%20Physics/6%20Statistics/Problem_1/#expectations","text":"The more skewed the original distribution, the larger the sample size needed for convergence. Uniform distributions converge more rapidly than exponential ones.","title":"Expectations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-practical-applications","text":"Understanding the CLT is essential in fields such as: Statistics: Confidence intervals and hypothesis testing rely on CLT. Manufacturing: Used in quality control to assess process stability. Finance: CLT helps model and assess risk using aggregated returns. Medical Trials: Helps ensure reliability of results from sampled patient data.","title":"4. Practical Applications"},{"location":"1%20Physics/6%20Statistics/Problem_1/#deliverables","text":"A Python script or notebook with simulations using NumPy, Matplotlib, and Seaborn. Plots illustrating sampling distributions from different population types. Mathematical definitions embedded next to each plot and concept. A Markdown discussion relating simulation results to theoretical expectations.","title":"Deliverables"},{"location":"1%20Physics/6%20Statistics/Problem_1/#code-hints","text":"Use numpy.random to generate populations and samples. Plot with seaborn.histplot() and overlay a normal curve using scipy.stats.norm.pdf. Use np.random.seed() for reproducibility.","title":"Code Hints"},{"location":"1%20Physics/6%20Statistics/Problem_1/#conclusion","text":"The Central Limit Theorem, though abstract in theory, becomes intuitive through computational experiments. Simulations show that regardless of the population\u2019s distribution, the mean of sufficiently large samples tends to be normally distributed. This underpins much of statistical inference, from confidence intervals to decision-making models. Each plot is supported by mathematical definitions to reinforce learning and interpretation.","title":"Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 Estimating \u03c0 Using Monte Carlo Methods Motivation Monte Carlo simulations are a powerful computational tool that use randomness to solve complex problems. One elegant application of this technique is estimating the value of \u03c0 through geometric probability. By randomly generating points and analyzing their distribution relative to geometric shapes, we can approximate \u03c0 in a visual and intuitive way. This approach not only connects core principles from probability, geometry, and numerical computation but also serves as an accessible entry point into the broader applications of Monte Carlo methods in physics, finance, and computer science. Part 1: Estimating \u03c0 Using a Circle 1. Theoretical Foundation To estimate \u03c0, consider a unit circle (radius = 1) inscribed within a square with side length 2. The area of the circle is: \\[ A_{\\text{circle}} = \\pi r^2 = \\pi \\] The area of the square is: \\[ A_{\\text{square}} = (2)^2 = 4 \\] The ratio of the areas is: \\[ \\frac{A_{\\text{circle}}}{A_{\\text{square}}} = \\frac{\\pi}{4} \\] By generating random points uniformly within the square and checking how many fall inside the circle, we can estimate \u03c0 using: \\[ \\pi \\approx 4 \\cdot \\frac{N_{\\text{inside}}}{N_{\\text{total}}} \\] 2. Simulation Generate N random (x, y) points in the square \\([-1, 1] \\times [-1, 1]\\) Count how many satisfy \\(x^2 + y^2 \\leq 1\\) Estimate \u03c0 with the above formula import numpy as np import matplotlib.pyplot as plt def estimate_pi_circle(num_points): x = np.random.uniform(-1, 1, num_points) y = np.random.uniform(-1, 1, num_points) inside = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside) / num_points return pi_estimate, x, y, inside # Generate points and estimate \u03c0 np.random.seed(42) pi_estimate, x, y, inside = estimate_pi_circle(10000) # Plot plt.figure(figsize=(6, 6)) plt.scatter(x[inside], y[inside], color='blue', s=1, label='Inside Circle') plt.scatter(x[~inside], y[~inside], color='red', s=1, label='Outside Circle') plt.gca().set_aspect('equal') plt.title(f'Circle-Based Monte Carlo\\nEstimated \u03c0 \u2248 {pi_estimate:.5f}') plt.legend() plt.grid(True) plt.show() 3. Visualization 4. Analysis By increasing the number of random points, the estimate of \u03c0 becomes more accurate due to the Law of Large Numbers. A plot of \u03c0 estimates against the number of iterations can show how the estimate converges. def convergence_circle(max_points, step): estimates = [] for n in range(step, max_points + 1, step): pi_estimate, _, _, _ = estimate_pi_circle(n) estimates.append((n, pi_estimate)) return np.array(estimates) # Convergence data circle_convergence = convergence_circle(50000, 1000) # Plot plt.figure(figsize=(8, 5)) plt.plot(circle_convergence[:, 0], circle_convergence[:, 1], color='blue', label='Estimated \u03c0') plt.axhline(y=np.pi, color='gray', linestyle='--', label='True \u03c0') plt.title('Convergence of \u03c0 Estimate - Circle-Based Method') plt.xlabel('Number of Points') plt.ylabel('Estimated \u03c0') plt.grid(True) plt.legend() plt.show() Part 2: Estimating \u03c0 Using Buffon\u2019s Needle 1. Theoretical Foundation Buffon\u2019s Needle is a probability experiment where a needle of length \\(L\\) is dropped on a plane with equally spaced parallel lines a distance \\(d\\) apart. If \\(L \\leq d\\) , the probability \\(P\\) that the needle crosses a line is: \\[ P = \\frac{2L}{\\pi d} \\] Rearranging to estimate \u03c0: \\[ \\pi \\approx \\frac{2L \\cdot N_{\\text{total}}}{d \\cdot N_{\\text{cross}}} \\] 2. Simulation Set values for \\(L\\) and \\(d\\) , with \\(L \\leq d\\) Randomly drop needles by generating center points and angles Count the number of needles crossing a line Estimate \u03c0 with the derived formula def estimate_pi_buffon(num_needles, needle_length=1.0, line_spacing=2.0): x_center = np.random.uniform(0, line_spacing / 2, num_needles) theta = np.random.uniform(0, np.pi / 2, num_needles) crosses = x_center <= (needle_length / 2) * np.sin(theta) pi_estimate = (2 * needle_length * num_needles) / (line_spacing * np.sum(crosses)) if np.sum(crosses) > 0 else np.nan return pi_estimate, x_center, theta, crosses # Simulate and plot np.random.seed(42) pi_estimate, x_center, theta, crosses = estimate_pi_buffon(10000) line_spacing = 2.0 plt.figure(figsize=(6, 6)) for i in range(6): plt.axhline(y=i, color='black', linestyle='--', linewidth=0.5) for i in range(len(x_center)): y_center = np.random.uniform(0, 5) theta_i = theta[i] x1 = x_center[i] - (0.5 * np.cos(theta_i)) x2 = x_center[i] + (0.5 * np.cos(theta_i)) y1 = y_center - (0.5 * np.sin(theta_i)) y2 = y_center + (0.5 * np.sin(theta_i)) color = 'green' if crosses[i] else 'orange' plt.plot([x1, x2], [y1, y2], color=color, linewidth=0.5) plt.xlim(0, line_spacing) plt.ylim(0, 5) plt.gca().set_aspect('equal') plt.title(f\"Buffon's Needle Simulation\\nEstimated \u03c0 \u2248 {pi_estimate:.5f}\") plt.grid(True) plt.show() 3. Visualization 4. Analysis Track how \u03c0 estimation improves with more drops Compare convergence rate to the circle-based method Discuss limitations, such as sensitivity to small sample sizes and angular uniformity def convergence_buffon(max_needles, step, needle_length=1.0, line_spacing=2.0): estimates = [] for n in range(step, max_needles + 1, step): pi_estimate, _, _, _ = estimate_pi_buffon(n, needle_length, line_spacing) estimates.append((n, pi_estimate)) return np.array(estimates) # Convergence data buffon_convergence = convergence_buffon(50000, 1000) # Plot plt.figure(figsize=(8, 5)) plt.plot(buffon_convergence[:, 0], buffon_convergence[:, 1], color='green', label=\"Estimated \u03c0\") plt.axhline(y=np.pi, color='gray', linestyle='--', label='True \u03c0') plt.title(\"Convergence of \u03c0 Estimate - Buffon's Needle Method\") plt.xlabel('Number of Needle Drops') plt.ylabel('Estimated \u03c0') plt.grid(True) plt.legend() plt.show() Comparison and Conclusion Method Convergence Speed Accuracy (at 100k samples) Complexity Notes Circle-Based Fast High Low Simple geometry, robust Buffon\u2019s Needle Slower Moderate Medium More sensitive to randomness Summary Both methods effectively demonstrate how Monte Carlo simulations can estimate \u03c0 using randomness. While the circle-based approach tends to converge faster and more smoothly, Buffon\u2019s Needle offers a historically significant and geometrically rich alternative. These simulations not only reinforce fundamental principles in mathematics and physics but also showcase the real-world applicability of probabilistic modeling.","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-using-monte-carlo-methods","text":"","title":"Estimating \u03c0 Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#motivation","text":"Monte Carlo simulations are a powerful computational tool that use randomness to solve complex problems. One elegant application of this technique is estimating the value of \u03c0 through geometric probability. By randomly generating points and analyzing their distribution relative to geometric shapes, we can approximate \u03c0 in a visual and intuitive way. This approach not only connects core principles from probability, geometry, and numerical computation but also serves as an accessible entry point into the broader applications of Monte Carlo methods in physics, finance, and computer science.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-estimating-using-a-circle","text":"","title":"Part 1: Estimating \u03c0 Using a Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation","text":"To estimate \u03c0, consider a unit circle (radius = 1) inscribed within a square with side length 2. The area of the circle is: \\[ A_{\\text{circle}} = \\pi r^2 = \\pi \\] The area of the square is: \\[ A_{\\text{square}} = (2)^2 = 4 \\] The ratio of the areas is: \\[ \\frac{A_{\\text{circle}}}{A_{\\text{square}}} = \\frac{\\pi}{4} \\] By generating random points uniformly within the square and checking how many fall inside the circle, we can estimate \u03c0 using: \\[ \\pi \\approx 4 \\cdot \\frac{N_{\\text{inside}}}{N_{\\text{total}}} \\]","title":"1. Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation","text":"Generate N random (x, y) points in the square \\([-1, 1] \\times [-1, 1]\\) Count how many satisfy \\(x^2 + y^2 \\leq 1\\) Estimate \u03c0 with the above formula import numpy as np import matplotlib.pyplot as plt def estimate_pi_circle(num_points): x = np.random.uniform(-1, 1, num_points) y = np.random.uniform(-1, 1, num_points) inside = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside) / num_points return pi_estimate, x, y, inside # Generate points and estimate \u03c0 np.random.seed(42) pi_estimate, x, y, inside = estimate_pi_circle(10000) # Plot plt.figure(figsize=(6, 6)) plt.scatter(x[inside], y[inside], color='blue', s=1, label='Inside Circle') plt.scatter(x[~inside], y[~inside], color='red', s=1, label='Outside Circle') plt.gca().set_aspect('equal') plt.title(f'Circle-Based Monte Carlo\\nEstimated \u03c0 \u2248 {pi_estimate:.5f}') plt.legend() plt.grid(True) plt.show()","title":"2. Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visualization","text":"","title":"3. Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-analysis","text":"By increasing the number of random points, the estimate of \u03c0 becomes more accurate due to the Law of Large Numbers. A plot of \u03c0 estimates against the number of iterations can show how the estimate converges. def convergence_circle(max_points, step): estimates = [] for n in range(step, max_points + 1, step): pi_estimate, _, _, _ = estimate_pi_circle(n) estimates.append((n, pi_estimate)) return np.array(estimates) # Convergence data circle_convergence = convergence_circle(50000, 1000) # Plot plt.figure(figsize=(8, 5)) plt.plot(circle_convergence[:, 0], circle_convergence[:, 1], color='blue', label='Estimated \u03c0') plt.axhline(y=np.pi, color='gray', linestyle='--', label='True \u03c0') plt.title('Convergence of \u03c0 Estimate - Circle-Based Method') plt.xlabel('Number of Points') plt.ylabel('Estimated \u03c0') plt.grid(True) plt.legend() plt.show()","title":"4. Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-estimating-using-buffons-needle","text":"","title":"Part 2: Estimating \u03c0 Using Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation_1","text":"Buffon\u2019s Needle is a probability experiment where a needle of length \\(L\\) is dropped on a plane with equally spaced parallel lines a distance \\(d\\) apart. If \\(L \\leq d\\) , the probability \\(P\\) that the needle crosses a line is: \\[ P = \\frac{2L}{\\pi d} \\] Rearranging to estimate \u03c0: \\[ \\pi \\approx \\frac{2L \\cdot N_{\\text{total}}}{d \\cdot N_{\\text{cross}}} \\]","title":"1. Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation_1","text":"Set values for \\(L\\) and \\(d\\) , with \\(L \\leq d\\) Randomly drop needles by generating center points and angles Count the number of needles crossing a line Estimate \u03c0 with the derived formula def estimate_pi_buffon(num_needles, needle_length=1.0, line_spacing=2.0): x_center = np.random.uniform(0, line_spacing / 2, num_needles) theta = np.random.uniform(0, np.pi / 2, num_needles) crosses = x_center <= (needle_length / 2) * np.sin(theta) pi_estimate = (2 * needle_length * num_needles) / (line_spacing * np.sum(crosses)) if np.sum(crosses) > 0 else np.nan return pi_estimate, x_center, theta, crosses # Simulate and plot np.random.seed(42) pi_estimate, x_center, theta, crosses = estimate_pi_buffon(10000) line_spacing = 2.0 plt.figure(figsize=(6, 6)) for i in range(6): plt.axhline(y=i, color='black', linestyle='--', linewidth=0.5) for i in range(len(x_center)): y_center = np.random.uniform(0, 5) theta_i = theta[i] x1 = x_center[i] - (0.5 * np.cos(theta_i)) x2 = x_center[i] + (0.5 * np.cos(theta_i)) y1 = y_center - (0.5 * np.sin(theta_i)) y2 = y_center + (0.5 * np.sin(theta_i)) color = 'green' if crosses[i] else 'orange' plt.plot([x1, x2], [y1, y2], color=color, linewidth=0.5) plt.xlim(0, line_spacing) plt.ylim(0, 5) plt.gca().set_aspect('equal') plt.title(f\"Buffon's Needle Simulation\\nEstimated \u03c0 \u2248 {pi_estimate:.5f}\") plt.grid(True) plt.show()","title":"2. Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visualization_1","text":"","title":"3. Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-analysis_1","text":"Track how \u03c0 estimation improves with more drops Compare convergence rate to the circle-based method Discuss limitations, such as sensitivity to small sample sizes and angular uniformity def convergence_buffon(max_needles, step, needle_length=1.0, line_spacing=2.0): estimates = [] for n in range(step, max_needles + 1, step): pi_estimate, _, _, _ = estimate_pi_buffon(n, needle_length, line_spacing) estimates.append((n, pi_estimate)) return np.array(estimates) # Convergence data buffon_convergence = convergence_buffon(50000, 1000) # Plot plt.figure(figsize=(8, 5)) plt.plot(buffon_convergence[:, 0], buffon_convergence[:, 1], color='green', label=\"Estimated \u03c0\") plt.axhline(y=np.pi, color='gray', linestyle='--', label='True \u03c0') plt.title(\"Convergence of \u03c0 Estimate - Buffon's Needle Method\") plt.xlabel('Number of Needle Drops') plt.ylabel('Estimated \u03c0') plt.grid(True) plt.legend() plt.show()","title":"4. Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#comparison-and-conclusion","text":"Method Convergence Speed Accuracy (at 100k samples) Complexity Notes Circle-Based Fast High Low Simple geometry, robust Buffon\u2019s Needle Slower Moderate Medium More sensitive to randomness","title":"Comparison and Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_2/#summary","text":"Both methods effectively demonstrate how Monte Carlo simulations can estimate \u03c0 using randomness. While the circle-based approach tends to converge faster and more smoothly, Buffon\u2019s Needle offers a historically significant and geometrically rich alternative. These simulations not only reinforce fundamental principles in mathematics and physics but also showcase the real-world applicability of probabilistic modeling.","title":"Summary"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 Measuring Earth's Gravitational Acceleration with a Pendulum Motivation The acceleration due to gravity, \\(g\\) , is a fundamental constant in physics, playing a critical role in mechanics, astronomy, and engineering. One of the simplest yet effective methods to measure \\(g\\) is by analyzing the motion of a simple pendulum. This experiment provides insight into precision measurement techniques and the treatment of uncertainties in experimental physics. Materials String: 1.000 \u00b1 0.005 m Weight: Metal washer Stopwatch (smartphone timer): Resolution \u00b10.01 s Ruler: Resolution \u00b10.005 m Setup Length of pendulum \\(L = 1.000 \\pm 0.005 \\, \\text{m}\\) (measured from suspension point to center of mass of the weight) Angle of release: < 15\u00b0 to approximate simple harmonic motion Data Collection Displaced the pendulum to a small angle and measured the time for 10 complete oscillations, repeated 10 times: Trial Time for 10 Oscillations (s) 1 20.11 2 20.15 3 20.12 4 20.10 5 20.13 6 20.16 7 20.14 8 20.11 9 20.12 10 20.10 Mean Time: \\[ \\bar{t} = \\frac{1}{10} \\sum t_i = \\frac{201.14}{10} = 20.114 \\, \\text{s} \\] Standard Deviation: \\[ \\sigma = \\sqrt{\\frac{1}{n-1} \\sum (t_i - \\bar{t})^2} \\approx 0.021 \\, \\text{s} \\] Uncertainty in Mean: \\[ u_t = \\frac{\\sigma}{\\sqrt{n}} = \\frac{0.021}{\\sqrt{10}} \\approx 0.007 \\, \\text{s} \\] Calculations 1. Period of the pendulum: \\[ T = \\frac{\\bar{t}}{10} = \\frac{20.114}{10} = 2.0114 \\, \\text{s} \\] \\[ u_T = \\frac{u_t}{10} = \\frac{0.007}{10} = 0.0007 \\, \\text{s} \\] 2. Gravitational acceleration: Using the formula \\(g = \\frac{4\\pi^2L}{T^2}\\) \\[ g = \\frac{4\\pi^2 \\cdot 1.000}{(2.0114)^2} \\approx \\frac{39.4784}{4.0458} \\approx 9.76 \\, \\text{m/s}^2 \\] 3. Uncertainty in \\(g\\) : \\[ \\frac{u_g}{g} = \\sqrt{\\left(\\frac{u_L}{L}\\right)^2 + \\left(2 \\cdot \\frac{u_T}{T} \\right)^2} \\] \\[ \\frac{u_g}{g} = \\sqrt{\\left(\\frac{0.005}{1.000}\\right)^2 + \\left(2 \\cdot \\frac{0.0007}{2.0114} \\right)^2} \\approx \\sqrt{(0.005)^2 + (0.0007)^2} \\approx 0.0051 \\] \\[ u_g = 0.0051 \\cdot 9.76 \\approx 0.05 \\, \\text{m/s}^2 \\] \\[ \\boxed{g = 9.76 \\pm 0.05 \\, \\text{m/s}^2} \\] Analysis and Discussion Comparison with Standard Value: Standard value: \\(g = 9.81 \\, \\text{m/s}^2\\) Measured value: \\(9.76 \\pm 0.05 \\, \\text{m/s}^2\\) Difference: 0.05 \\(\\Rightarrow\\) within experimental uncertainty Sources of Uncertainty: Length measurement : The most significant source due to \u00b10.005 m resolution Assumption of SHM : Only valid for small angles (<15\u00b0) Air resistance and pivot friction : Minor but present Improvements: Use a light gate or photogate timer for better timing accuracy Measure multiple lengths and plot \\(T^2\\) vs. \\(L\\) to find slope for \\(g\\) Use heavier mass to reduce air resistance effect Conclusion By analyzing the period of a pendulum with careful timing and uncertainty analysis, we determined the acceleration due to gravity to be: \\[ \\boxed{g = 9.76 \\pm 0.05 \\, \\text{m/s}^2} \\] This is in good agreement with the accepted standard value, demonstrating the effectiveness of the pendulum method in measuring gravitational acceleration.","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measuring-earths-gravitational-acceleration-with-a-pendulum","text":"","title":"Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#motivation","text":"The acceleration due to gravity, \\(g\\) , is a fundamental constant in physics, playing a critical role in mechanics, astronomy, and engineering. One of the simplest yet effective methods to measure \\(g\\) is by analyzing the motion of a simple pendulum. This experiment provides insight into precision measurement techniques and the treatment of uncertainties in experimental physics.","title":"Motivation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#materials","text":"String: 1.000 \u00b1 0.005 m Weight: Metal washer Stopwatch (smartphone timer): Resolution \u00b10.01 s Ruler: Resolution \u00b10.005 m","title":"Materials"},{"location":"1%20Physics/7%20Measurements/Problem_1/#setup","text":"Length of pendulum \\(L = 1.000 \\pm 0.005 \\, \\text{m}\\) (measured from suspension point to center of mass of the weight) Angle of release: < 15\u00b0 to approximate simple harmonic motion","title":"Setup"},{"location":"1%20Physics/7%20Measurements/Problem_1/#data-collection","text":"Displaced the pendulum to a small angle and measured the time for 10 complete oscillations, repeated 10 times: Trial Time for 10 Oscillations (s) 1 20.11 2 20.15 3 20.12 4 20.10 5 20.13 6 20.16 7 20.14 8 20.11 9 20.12 10 20.10","title":"Data Collection"},{"location":"1%20Physics/7%20Measurements/Problem_1/#mean-time","text":"\\[ \\bar{t} = \\frac{1}{10} \\sum t_i = \\frac{201.14}{10} = 20.114 \\, \\text{s} \\]","title":"Mean Time:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#standard-deviation","text":"\\[ \\sigma = \\sqrt{\\frac{1}{n-1} \\sum (t_i - \\bar{t})^2} \\approx 0.021 \\, \\text{s} \\]","title":"Standard Deviation:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#uncertainty-in-mean","text":"\\[ u_t = \\frac{\\sigma}{\\sqrt{n}} = \\frac{0.021}{\\sqrt{10}} \\approx 0.007 \\, \\text{s} \\]","title":"Uncertainty in Mean:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculations","text":"","title":"Calculations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-period-of-the-pendulum","text":"\\[ T = \\frac{\\bar{t}}{10} = \\frac{20.114}{10} = 2.0114 \\, \\text{s} \\] \\[ u_T = \\frac{u_t}{10} = \\frac{0.007}{10} = 0.0007 \\, \\text{s} \\]","title":"1. Period of the pendulum:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-gravitational-acceleration","text":"Using the formula \\(g = \\frac{4\\pi^2L}{T^2}\\) \\[ g = \\frac{4\\pi^2 \\cdot 1.000}{(2.0114)^2} \\approx \\frac{39.4784}{4.0458} \\approx 9.76 \\, \\text{m/s}^2 \\]","title":"2. Gravitational acceleration:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-uncertainty-in-g","text":"\\[ \\frac{u_g}{g} = \\sqrt{\\left(\\frac{u_L}{L}\\right)^2 + \\left(2 \\cdot \\frac{u_T}{T} \\right)^2} \\] \\[ \\frac{u_g}{g} = \\sqrt{\\left(\\frac{0.005}{1.000}\\right)^2 + \\left(2 \\cdot \\frac{0.0007}{2.0114} \\right)^2} \\approx \\sqrt{(0.005)^2 + (0.0007)^2} \\approx 0.0051 \\] \\[ u_g = 0.0051 \\cdot 9.76 \\approx 0.05 \\, \\text{m/s}^2 \\] \\[ \\boxed{g = 9.76 \\pm 0.05 \\, \\text{m/s}^2} \\]","title":"3. Uncertainty in \\(g\\):"},{"location":"1%20Physics/7%20Measurements/Problem_1/#analysis-and-discussion","text":"","title":"Analysis and Discussion"},{"location":"1%20Physics/7%20Measurements/Problem_1/#comparison-with-standard-value","text":"Standard value: \\(g = 9.81 \\, \\text{m/s}^2\\) Measured value: \\(9.76 \\pm 0.05 \\, \\text{m/s}^2\\) Difference: 0.05 \\(\\Rightarrow\\) within experimental uncertainty","title":"Comparison with Standard Value:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#sources-of-uncertainty","text":"Length measurement : The most significant source due to \u00b10.005 m resolution Assumption of SHM : Only valid for small angles (<15\u00b0) Air resistance and pivot friction : Minor but present","title":"Sources of Uncertainty:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#improvements","text":"Use a light gate or photogate timer for better timing accuracy Measure multiple lengths and plot \\(T^2\\) vs. \\(L\\) to find slope for \\(g\\) Use heavier mass to reduce air resistance effect","title":"Improvements:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#conclusion","text":"By analyzing the period of a pendulum with careful timing and uncertainty analysis, we determined the acceleration due to gravity to be: \\[ \\boxed{g = 9.76 \\pm 0.05 \\, \\text{m/s}^2} \\] This is in good agreement with the accepted standard value, demonstrating the effectiveness of the pendulum method in measuring gravitational acceleration.","title":"Conclusion"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}